 <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>AP Stats Consensus Quiz Renderer</title>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
      <!-- Chart.js DataLabels plugin for point labeling -->
      <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
      <!-- MathJax for rendering LaTeX/TeX notation in prompts, choices, and explanations -->
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
      <style>
          body {
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
              max-width: 900px;
              margin: 0 auto;
              padding: 20px;
              background-color: #f5f5f5;
              line-height: 1.6;
          }
          .container {
              background: white;
              padding: 30px;
              border-radius: 10px;
              box-shadow: 0 2px 10px rgba(0,0,0,0.1);
              margin-bottom: 20px;
          }
          h1 {
              color: #2c3e50;
              text-align: center;
              margin-bottom: 30px;
          }
          .upload-section {
              background: #f8f9fa;
              border: 2px dashed #dee2e6;
              border-radius: 8px;
              padding: 25px;
              margin-bottom: 30px;
              text-align: center;
          }
          .json-input {
              width: 100%;
              height: 200px;
              font-family: monospace;
              font-size: 14px;
              border: 2px solid #ddd;
              border-radius: 6px;
              padding: 15px;
              margin-bottom: 15px;
              resize: vertical;
              box-sizing: border-box;
          }
          .load-button {
              background: #28a745;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 16px;
              font-weight: bold;
              transition: background 0.3s ease;
              margin: 5px;
          }
          .load-button:hover {
              background: #218838;
          }
          .clear-button {
              background: #6c757d;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 16px;
              font-weight: bold;
              transition: background 0.3s ease;
              margin: 5px;
          }
          .clear-button:hover {
              background: #545b62;
          }
          .debug-button {
              background: #6f42c1;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 16px;
              font-weight: bold;
              transition: all 0.3s ease;
              margin: 5px;
              box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          }
          .debug-button:hover {
              background: #5a2d9c;
              transform: translateY(-1px);
              box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          }
          .file-input {
              margin-bottom: 15px;
              padding: 10px;
              border: 2px solid #ddd;
              border-radius: 6px;
              font-size: 16px;
              width: 100%;
              box-sizing: border-box;
          }
          .quiz-container {
              background: white;
              border: 2px solid #3498db;
              border-radius: 8px;
              padding: 25px;
              margin-bottom: 30px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          }
          .question-header {
              background: #3498db;
              color: white;
              padding: 10px 15px;
              margin: -25px -25px 20px -25px;
              border-radius: 6px 6px 0 0;
              font-weight: bold;
              font-size: 18px;
          }
          .question-id {
              color: #666;
              font-size: 0.9em;
              margin-bottom: 10px;
          }
          .question-prompt {
              font-weight: bold;
              margin-bottom: 15px;
              font-size: 1.1em;
              color: #2c3e50;
          }
          .table-container {
              margin: 15px 0;
              overflow-x: auto;
          }
          table {
              border-collapse: collapse;
              width: 100%;
              margin: 10px 0;
              background: #f8f9fa;
          }
          th, td {
              border: 1px solid #ddd;
              padding: 12px 15px;
              text-align: left;
          }
          th {
              background-color: #343a40;
              color: white;
              font-weight: bold;
          }
          tr:nth-child(even) {
              background-color: #f8f9fa;
          }
          .chart-container {
              margin: 20px 0;
              background: white;
              padding: 20px;
              border-radius: 8px;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
              border: 2px solid #e9ecef;
          }
          .chart-title {
              text-align: center;
              margin-bottom: 15px;
              font-weight: bold;
              color: #495057;
          }
          .chart-canvas {
              position: relative;
              height: 400px;
              width: 100%;
          }
          .multiple-charts-container {
              display: flex;
              gap: 20px;
              flex-wrap: wrap;
              justify-content: center;
              margin: 20px 0;
          }
          .multiple-charts-container .chart-container {
              flex: 1;
              min-width: 300px;
              max-width: 450px;
          }
          .image-container {
              margin: 15px 0;
              text-align: center;
          }
          .question-image {
              max-width: 100%;
              height: auto;
              margin: 10px 0;
              border-radius: 4px;
          }
          .image-caption {
              text-align: center;
              font-style: italic;
              color: #666;
              margin-top: 5px;
              font-size: 0.9em;
          }
          .images-container {
              display: flex;
              flex-wrap: wrap;
              gap: 15px;
              justify-content: center;
              margin: 15px 0;
          }
          .images-container .image-container {
              flex: 1;
              min-width: 200px;
              max-width: 400px;
          }
          .choices {
              margin-top: 15px;
          }
          .choice {
              background: #f8f9fa;
              border: 2px solid #e9ecef;
              border-radius: 6px;
              padding: 12px 15px;
              margin: 8px 0;
              transition: all 0.3s ease;
              display: flex;
              align-items: center;
          }
          .choice:hover {
              background: #fff9c4;
              border-color: #ffd54f;
          }
          .choice input[type="radio"] {
              margin-right: 10px;
              cursor: pointer;
          }
          .choice label {
              cursor: pointer;
              display: flex;
              align-items: center;
          }
          .reason-wrapper {
              margin-top: 15px;
              margin-bottom: 15px;
          }
          .reason-textarea {
              width: 100%;
              min-height: 60px;
              padding: 10px;
              border: 1px solid #ddd;
              border-radius: 4px;
              font-family: inherit;
              font-size: 14px;
              resize: vertical;
          }
          .reason-textarea:focus {
              outline: none;
              border-color: #4CAF50;
              box-shadow: 0 0 5px rgba(76, 175, 80, 0.2);
          }
          .frq-textarea {
              width: 100%;
              min-height: 150px;
              padding: 10px;
              border: 2px solid #ddd;
              border-radius: 4px;
              font-family: inherit;
              font-size: 14px;
              resize: vertical;
          }
          .frq-textarea:focus {
              outline: none;
              border-color: #2196F3;
              box-shadow: 0 0 5px rgba(33, 150, 243, 0.2);
          }
          .submit-button {
              background: #4CAF50;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
              font-weight: bold;
              margin-top: 10px;
          }
          .submit-button:hover:not(:disabled) {
              background: #45a049;
          }
          .submit-button:disabled {
              background: #ccc;
              cursor: not-allowed;
          }
          .validation-error {
              color: #f44336;
              font-size: 14px;
              margin-top: 5px;
              display: none;
          }
          .validation-error.show {
              display: block;
          }
          .submission-success {
              color: #4CAF50;
              font-size: 14px;
              margin-top: 5px;
              display: none;
          }
          .submission-success.show {
              display: block;
          }
          .max-attempts-message {
              color: #ff9800;
              font-size: 14px;
              margin-top: 10px;
              font-weight: bold;
          }
          .username-welcome {
              background: #e3f2fd;
              padding: 10px;
              border-radius: 4px;
              margin-bottom: 20px;
              text-align: center;
              font-weight: bold;
              color: #1976d2;
          }
          .username-prompt {
              background: #fff3e0;
              padding: 15px;
              border-radius: 4px;
              margin-bottom: 20px;
              text-align: center;
          }
          .username-input {
              padding: 8px 12px;
              border: 2px solid #ff9800;
              border-radius: 4px;
              font-size: 14px;
              margin: 0 10px;
          }
          .choice-key {
              font-weight: bold;
              display: inline-block;
              width: 30px;
              color: #495057;
          }

          /* New consensus app styles */
          .app-controls {
              margin-bottom: 20px;
              padding: 15px;
              background: #f8f9fa;
              border-radius: 8px;
              display: flex;
              justify-content: space-between;
              align-items: center;
              flex-wrap: wrap;
              gap: 10px;
          }
          .user-info {
              flex: 1;
              min-width: 200px;
          }
          .user-info input {
              width: 100%;
              padding: 8px 12px;
              border: 2px solid #ddd;
              border-radius: 5px;
              font-size: 14px;
          }
          .filter-controls {
              flex: 2;
              min-width: 300px;
          }
          #modeToggle {
              padding: 10px 20px;
              background: #007bff;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              font-weight: bold;
              transition: background 0.3s ease;
          }
          #modeToggle:hover {
              background: #0056b3;
          }
          .question-controls {
              margin-top: 15px;
              padding-top: 15px;
              border-top: 2px solid #e9ecef;
          }
          .answer-section {
              display: none;
          }
          .reason-input {
              width: 100%;
              min-height: 80px;
              margin: 10px 0;
              padding: 10px;
              border: 2px solid #ddd;
              border-radius: 5px;
              font-family: inherit;
              font-size: 14px;
              resize: vertical;
          }
          .submit-answer {
              padding: 10px 20px;
              background: #28a745;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              font-weight: bold;
              transition: background 0.3s ease;
          }
          .submit-answer:hover:not(:disabled) {
              background: #218838;
          }
          .submit-answer:disabled {
              opacity: 0.6;
              cursor: not-allowed;
          }
          .view-section {
              display: none;
              padding: 15px;
              background: #f8f9fa;
              border-radius: 5px;
          }

          /* Mode-specific visibility */
          body[data-mode="answer"] .answer-section {
              display: block;
          }
          body[data-mode="view"] .view-section {
              display: block;
          }

          .error {
              background: #f8d7da;
              border: 2px solid #dc3545;
              color: #721c24;
              padding: 15px;
              border-radius: 6px;
              margin: 20px 0;
          }
          .success {
              background: #d4edda;
              border: 2px solid #28a745;
              color: #155724;
              padding: 15px;
              border-radius: 6px;
              margin: 20px 0;
          }
          .stats {
              background: #e7f3ff;
              border: 2px solid #0066cc;
              border-radius: 6px;
              padding: 15px;
              margin: 20px 0;
              text-align: center;
          }

          /* Dark mode adaptations */
          body.dark-theme {
              background-color: #1a1a1a;
              color: #e0e0e0;
          }

          body.dark-theme .container {
              background: #2d2d2d;
              color: #e0e0e0;
          }

          body.dark-theme .upload-section {
              background: #333333;
              border-color: #555555;
              color: #e0e0e0;
          }

          body.dark-theme .quiz-container {
              background: #2d2d2d;
              border-color: #5BC0EB;
              color: #e0e0e0;
          }

          body.dark-theme .question-header {
              background: #5BC0EB;
              color: #1a1a1a;
          }

          body.dark-theme .chart-container {
              background: #2d2d2d;
              border-color: #555555;
          }

          body.dark-theme .choice {
              background: #333333;
              border-color: #555555;
              color: #e0e0e0;
          }

          body.dark-theme .choice:hover {
              background: #665c00;
              border-color: #ffcc00;
              color: #fffbe6;
          }

          body.dark-theme .app-controls {
              background: #333333;
              color: #e0e0e0;
          }

          body.dark-theme .question-controls {
              border-top-color: #555555;
          }

          body.dark-theme .reason-input {
              background: #404040;
              border-color: #555555;
              color: #e0e0e0;
          }

          body.dark-theme .view-section {
              background: #333333;
          }

          body.dark-theme .stats {
              background: #1e3a5f;
              border-color: #5BC0EB;
              color: #e0e0e0;
          }

          body.dark-theme table {
              background: #333333;
              color: #e0e0e0;
          }

          body.dark-theme th {
              background-color: #1a1a1a;
          }

          body.dark-theme tr:nth-child(even) {
              background-color: #404040;
          }

          body.dark-theme td, body.dark-theme th {
              border-color: #555555;
          }

          /* Floating Context Finder */
          .context-finder {
              position: fixed;
              top: 20px;
              right: 20px;
              background: white;
              border: 2px solid #3498db;
              border-radius: 8px;
              padding: 12px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
              max-width: 200px;
              font-size: 0.9em;
              color: #495057;
              z-index: 1000;
          }

          body.dark-theme .context-finder {
              background: #2d2d2d;
              color: #e0e0e0;
              border-color: #5BC0EB;
          }

          /* Theme toggle button */
          .theme-toggle {
              position: fixed;
              bottom: 20px;
              right: 20px;
              width: 50px;
              height: 50px;
              border-radius: 50%;
              border: 2px solid #3498db;
              background: white;
              color: #3498db;
              font-size: 24px;
              cursor: pointer;
              box-shadow: 0 2px 8px rgba(0,0,0,0.15);
              transition: all 0.3s ease;
              z-index: 1001;
          }

          .theme-toggle:hover {
              transform: scale(1.1);
              box-shadow: 0 4px 12px rgba(0,0,0,0.25);
          }

          body.dark-theme .theme-toggle {
              background: #2d2d2d;
              color: #ffd700;
              border-color: #ffd700;
          }

          /* Volume control */
          .volume-control {
              position: fixed;
              bottom: 80px;
              right: 20px;
              background: white;
              border: 2px solid #3498db;
              border-radius: 8px;
              padding: 10px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.15);
              z-index: 1001;
          }

          body.dark-theme .volume-control {
              background: #2d2d2d;
              border-color: #5BC0EB;
          }

          .volume-slider {
              width: 100px;
          }

          /* Step 3 additions */
          .error-msg {
              color: red;
              font-weight: bold;
              display: none;
              margin-top: 5px;
          }
          .completed {
              border-left: 4px solid green;
              padding-left: 10px;
          }
          .checkmark {
              color: green;
              font-size: 1.2em;
              margin-left: 5px;
          }
          .disabled {
              opacity: 0.5;
              pointer-events: none;
              background-color: #f0f0f0;
          }
          #sync-status {
              color: blue;
              margin-left: 10px;
              font-weight: bold;
          }
          
          /* Step 5: View section styles */
          .view-section {
              border: 1px solid #ccc;
              padding: 10px;
              margin: 10px 0;
              display: none;
              background: #f9f9f9;
              border-radius: 5px;
          }
          .view-section.show {
              display: block;
          }
          .consensus {
              color: green;
              font-weight: bold;
              padding: 5px;
              background: #e8f5e9;
              border-radius: 3px;
              display: inline-block;
              margin: 5px 0;
          }
          .low-consensus {
              color: red;
              font-style: italic;
              padding: 5px;
              background: #ffebee;
              border-radius: 3px;
              display: inline-block;
              margin: 5px 0;
          }
          .vote-btn {
              padding: 4px 8px;
              margin: 2px;
              border: none;
              border-radius: 3px;
              cursor: pointer;
              font-size: 12px;
          }
          .approve-btn {
              background: #4caf50;
              color: white;
          }
          .approve-btn:hover {
              background: #45a049;
          }
          .disapprove-btn {
              background: #f44336;
              color: white;
          }
          .disapprove-btn:hover {
              background: #da190b;
          }
          .response-li {
              border: 1px solid #ddd;
              padding: 8px;
              margin: 5px 0;
              background: white;
              border-radius: 3px;
              list-style: none;
          }
          .preview-note {
              color: gray;
              font-style: italic;
              padding: 10px;
              text-align: center;
          }
          .side-by-side {
              display: flex;
              gap: 20px;
          }
          .side-by-side > div {
              flex: 1;
          }
          .contributors-list {
              margin-top: 15px;
              padding: 10px;
              background: white;
              border-radius: 3px;
          }
          .contributor-item {
              padding: 5px 0;
              border-bottom: 1px solid #eee;
          }
          .contributor-item:last-child {
              border-bottom: none;
          }
          .vote-reason-input {
              width: 100%;
              padding: 4px;
              margin: 4px 0;
              border: 1px solid #ddd;
              border-radius: 3px;
              font-size: 12px;
              display: none;
          }
          .vote-reason-input.show {
              display: block;
          }
          .vote-record {
              font-size: 12px;
              color: #666;
              margin: 2px 0;
              padding: 3px 5px;
              background: #f5f5f5;
              border-radius: 2px;
          }
          .dotplot-container {
              margin: 20px 0;
              padding: 15px;
              background: white;
              border-radius: 5px;
          }
          .net-votes {
              font-weight: bold;
              padding: 2px 6px;
              border-radius: 3px;
              margin-left: 10px;
          }
          .net-votes.positive {
              background: #c8e6c9;
              color: #2e7d32;
          }
          .net-votes.negative {
              background: #ffcdd2;
              color: #c62828;
          }
          .net-votes.neutral {
              background: #e0e0e0;
              color: #616161;
          }
      </style>
  </head>
  <body>
      <div class="container">
          <h1>🧮 AP Statistics Consensus Quiz Renderer</h1>

          <div class="upload-section">
              <h2>📥 Load Quiz Data</h2>
              <input type="file" id="fileInput" class="file-input" accept=".json">
              <p>or paste JSON content below:</p>
              <textarea id="jsonInput" class="json-input" placeholder='Paste your JSON data here. Example:
  [
      {
          "id": "U1-L1-Q01",
          "type": "multiple-choice",
          "prompt": "What is the mean of [1, 2, 3, 4, 5]?",
          "choices": [
              {"key": "A", "value": "2"},
              {"key": "B", "value": "3"},
              {"key": "C", "value": "4"},
              {"key": "D", "value": "5"}
          ]
      }
  ]'></textarea>
              <button onclick="loadFromFile()" class="load-button">📁 Load from File</button>
              <button onclick="loadFromTextarea()" class="load-button">📝 Load from Text</button>
              <button onclick="clearQuiz()" class="clear-button">🗑️ Clear Quiz</button>
              <button onclick="loadDebugData()" class="debug-button">🔧 Load Debug Data</button>
          </div>

          <div id="messageArea"></div>
          <div id="statsArea"></div>
          <div id="questionsContainer"></div>
      </div>

      <!-- Volume control slider -->
      <div class="volume-control">
          <label for="volumeSlider">🔊</label>
          <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="50">
          <span id="volumeLabel">50%</span>
      </div>

      <!-- Theme toggle button -->
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">🌙</button>

      <!-- Floating context finder (hidden until questions are rendered) -->
      <div id="contextFinder" class="context-finder" style="display:none;"></div>

      <script>
          let chartInstances = [];
          let currentTheme = 'light'; // Default to light theme
          let audioContext = null;
          let globalVolume = 0.5;
          let contextObserver = null;
          let contextScrollHandlerAttached = false;

          // User data storage - Step 3: These will be removed after migration
          let currentUsername = null;
          let userAnswers = {};
          let userReasons = {};

          // Step 3: New localStorage-based storage
          let classData = null;
          let completed = new Set();

          // Initialize audio context
          function initAudioContext() {
              if (!audioContext) {
                  audioContext = new (window.AudioContext || window.webkitAudioContext)();
              }
          }

          // Volume control
          const volumeSlider = document.getElementById('volumeSlider');
          const volumeLabel = document.getElementById('volumeLabel');

          volumeSlider.addEventListener('input', (e) => {
              globalVolume = e.target.value / 100;
              volumeLabel.textContent = `${e.target.value}%`;
          });

          // Enhanced audio feedback system
          const buttonTones = {
              success: () => playTone([523, 659, 784], 150), // C-E-G major chord
              error: () => playTone([349, 330], 200), // F-E descending
              click: () => playTone([440], 50), // A4 short click
              hover: () => playTone([554], 30), // C#5 very short
              load: () => playTone([392, 523, 659], 100), // G-C-E
              clear: () => playTone([659, 523, 392], 100), // E-C-G descending
          };

          function playTone(frequencies, duration) {
              initAudioContext();
              if (!audioContext) return;

              frequencies.forEach((freq, index) => {
                  setTimeout(() => {
                      const oscillator = audioContext.createOscillator();
                      const gainNode = audioContext.createGain();

                      oscillator.connect(gainNode);
                      gainNode.connect(audioContext.destination);

                      oscillator.frequency.value = freq;
                      oscillator.type = 'sine';

                      gainNode.gain.setValueAtTime(globalVolume * 0.3, audioContext.currentTime);
                      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + (duration / 1000));

                      oscillator.start(audioContext.currentTime);
                      oscillator.stop(audioContext.currentTime + (duration / 1000));
                  }, index * 50);
              });
          }

          // Step 3: Initialize class data structure in localStorage
          function initClassData() {
              let classDataStr = localStorage.getItem('classData');
              classData = classDataStr ? JSON.parse(classDataStr) : {users: {}};

              if (!classData.users[currentUsername]) {
                  classData.users[currentUsername] = {
                      answers: {},
                      reasons: {},
                      timestamps: {},
                      attempts: {}
                  };
              }

              // Migrate in-memory data if exists
              if (userAnswers[currentUsername]) {
                  for (let qId in userAnswers[currentUsername]) {
                      if (!classData.users[currentUsername].answers[qId]) {
                          classData.users[currentUsername].answers[qId] = {
                              value: userAnswers[currentUsername][qId].answer || userAnswers[currentUsername][qId],
                              attempt: 1,
                              timestamp: Date.now()
                          };
                      }
                  }
                  delete userAnswers[currentUsername];
              }

              if (userReasons[currentUsername]) {
                  for (let qId in userReasons[currentUsername]) {
                      if (!classData.users[currentUsername].reasons[qId]) {
                          classData.users[currentUsername].reasons[qId] = userReasons[currentUsername][qId];
                      }
                  }
                  delete userReasons[currentUsername];
              }

              try {
                  localStorage.setItem('classData', JSON.stringify(classData));
              } catch(e) {
                  console.log("Storage quota exceeded—data not saved");
              }

              // Load completed set
              let completedStr = localStorage.getItem('completed');
              completed = completedStr ? new Set(JSON.parse(completedStr)) : new Set();
          }

          // Username management
          function promptUsername() {
              const savedUsername = localStorage.getItem('consensusUsername');
              if (savedUsername) {
                  currentUsername = savedUsername;
                  initClassData();
                  showUsernameWelcome();
              } else {
                  showUsernamePrompt();
              }
          }

          function showUsernamePrompt() {
              const container = document.querySelector('.container');
              if (!container) return;
              const promptDiv = document.createElement('div');
              promptDiv.className = 'username-prompt';
              promptDiv.innerHTML = `
                  <label>Enter your username: 
                      <input type="text" class="username-input" id="usernameInput" placeholder="Your name">
                      <button onclick="saveUsername()" class="submit-button">Start</button>
                  </label>
              `;
              container.insertBefore(promptDiv, container.firstChild);
          }

          window.saveUsername = function() {
              const input = document.getElementById('usernameInput');
              if (input && input.value.trim()) {
                  currentUsername = input.value.trim();
                  localStorage.setItem('consensusUsername', currentUsername);

                  // Step 3: Initialize class data structure
                  initClassData();

                  // Remove prompt and show welcome
                  const prompt = document.querySelector('.username-prompt');
                  if (prompt) prompt.remove();
                  showUsernameWelcome();
              }
          }

          function showUsernameWelcome() {
              const container = document.querySelector('.container');
              if (!container) return;
              const existingWelcome = document.querySelector('.username-welcome');
              if (existingWelcome) existingWelcome.remove();

              const welcomeDiv = document.createElement('div');
              welcomeDiv.className = 'username-welcome';
              welcomeDiv.textContent = `Welcome ${currentUsername} - Your contributions are visible for reputation!`;
              container.insertBefore(welcomeDiv, container.firstChild);
          }

          // Attempt tracking
          function getAttemptCount(questionId) {
              const key = `attempts_${questionId}`;
              return parseInt(localStorage.getItem(key) || '0');
          }

          function incrementAttemptCount(questionId) {
              const key = `attempts_${questionId}`;
              const current = getAttemptCount(questionId);
              localStorage.setItem(key, (current + 1).toString());
              return current + 1;
          }

          function isQuestionCompleted(questionId) {
              return localStorage.getItem(`completed_${questionId}`) === 'true';
          }

          function markQuestionCompleted(questionId) {
              localStorage.setItem(`completed_${questionId}`, 'true');
          }

          // Step 3: Modified answer submission with localStorage
          window.submitAnswer = function(questionId, questionType) {
              if (!currentUsername) {
                  alert('Please enter your username first!');
                  return;
              }

              // Check attempts from classData
              let currentAttempt = classData.users[currentUsername].attempts[questionId] || 0;
              if (currentAttempt >= 3) {
                  console.log('Max attempts reached');
                  return;
              }

              // Get error span
              let errorSpan = document.getElementById('error-' + questionId);
              if (errorSpan) {
                  errorSpan.style.display = 'none';
              }

              let value = '';

              // Get answer based on question type
              if (questionType === 'multiple-choice') {
                  let radios = document.querySelectorAll(`input[name="choice-${questionId}"]`);
                  for (let radio of radios) {
                      if (radio.checked) {
                          value = radio.value;
                          break;
                      }
                  }
                  if (!value) {
                      if (errorSpan) {
                          errorSpan.textContent = 'Please select an answer';
                          errorSpan.style.display = 'block';
                      }
                      return;
                  }
              } else {
                  let textarea = document.getElementById('frq-textarea-' + questionId);
                  if (textarea) {
                      value = textarea.value.trim();
                  }
                  if (!value) {
                      if (errorSpan) {
                          errorSpan.textContent = 'Please fill the response';
                          errorSpan.style.display = 'block';
                      }
                      return;
                  }
              }

              // Get reason
              let reason = '';
              let reasonTextarea = document.getElementById('reason-textarea-' + questionId);
              if (reasonTextarea) {
                  reason = reasonTextarea.value.trim();
              }

              // Update classData
              classData.users[currentUsername].answers[questionId] = {
                  value: value,
                  attempt: currentAttempt + 1,
                  timestamp: Date.now()
              };
              classData.users[currentUsername].reasons[questionId] = reason;
              classData.users[currentUsername].timestamps[questionId] = Date.now();
              classData.users[currentUsername].attempts[questionId] = currentAttempt + 1;

              // Save to localStorage
              try {
                  localStorage.setItem('classData', JSON.stringify(classData));
              } catch(e) {
                  console.log("Storage quota exceeded—data not saved");
              }

              // Update completed set
              completed.add(questionId);
              localStorage.setItem('completed', JSON.stringify(Array.from(completed)));

              // Update UI
              let submitBtn = document.getElementById('submit-' + questionId);
              if (submitBtn) {
                  submitBtn.textContent = `Submitted (Attempt ${currentAttempt + 1}/3)`;
                  if (currentAttempt + 1 >= 3) {
                      submitBtn.disabled = true;
                      submitBtn.classList.add('disabled');

                      // Disable all inputs
                      document.querySelectorAll(`[data-question-id="${questionId}"] input, [data-question-id="${questionId}"] textarea, [data-question-id="${questionId}"] 
  button`).forEach(el => {
                          el.classList.add('disabled');
                          el.disabled = true;
                      });

                      // Add max attempts message
                      let msg = document.createElement('span');
                      msg.textContent = 'Max attempts reached (3/3)';
                      msg.style.color = 'red';
                      msg.style.marginLeft = '10px';
                      submitBtn.parentNode.appendChild(msg);
                  }
              }

              // Add completed class and checkmark
              let qDiv = document.querySelector(`[data-question-id="${questionId}"]`);
              if (qDiv) {
                  qDiv.classList.add('completed');
                  if (!qDiv.querySelector('.checkmark')) {
                      let check = document.createElement('span');
                      check.className = 'checkmark';
                      check.textContent = '✓';
                      qDiv.querySelector('.question-header').appendChild(check);
                  }
              }

              // Enable view button if exists
              let viewBtn = document.querySelector(`#view-${questionId}`);
              if (viewBtn) {
                  viewBtn.disabled = false; viewBtn.style.display = "inline-block";
              }

              // Show success message
              let successMsg = document.getElementById('success-' + questionId);
              if (successMsg) {
                  successMsg.textContent = `Answer submitted! (Attempt ${currentAttempt + 1} of 3)`;
                  successMsg.classList.add('show');
              }
          }

          // Step 3: Load progress function
          function loadProgress() {
              if (!currentUsername || !classData) return;

              // Restore completed questions UI
              for (let qId of completed) {
                  let qDiv = document.querySelector(`[data-question-id="${qId}"]`);
                  if (qDiv) {
                      qDiv.classList.add('completed');
                      if (!qDiv.querySelector('.checkmark')) {
                          let check = document.createElement('span');
                          check.className = 'checkmark';
                          check.textContent = '✓';
                          let header = qDiv.querySelector('.question-header');
                          if (header) header.appendChild(check);
                      }
                      let viewBtn = qDiv.querySelector('.view-button');
                      if (viewBtn) { viewBtn.disabled = false; viewBtn.style.display = "inline-block"; }
                  }
              }

              // Restore answers and UI state for each question
              for (let qId in classData.users[currentUsername].answers) {
                  let qDiv = document.querySelector(`[data-question-id="${qId}"]`);

                  if (qDiv) {
                      let saved = classData.users[currentUsername].answers[qId];
                      let questionType = qDiv.querySelector('input[type="radio"]') ? 'multiple-choice' : 'free-response';

                      // Restore answer value
                      if (questionType === 'multiple-choice') {
                          let radios = qDiv.querySelectorAll(`input[name="choice-${qId}"]`);
                          for (let radio of radios) {
                              if (radio.value === saved.value) {
                                  radio.checked = true;
                                  break;
                              }
                          }
                      } else {
                          let textarea = qDiv.querySelector(`#frq-textarea-${qId}`);
                          if (textarea) {
                              textarea.value = saved.value;
                          }
                      }

                      // Restore reason
                      let reasonTa = qDiv.querySelector(`#reason-textarea-${qId}`);
                      if (reasonTa && classData.users[currentUsername].reasons[qId]) {
                          reasonTa.value = classData.users[currentUsername].reasons[qId];
                      }

                      // Update submit button and handle max attempts
                      let attempts = classData.users[currentUsername].attempts[qId] || 0;
                      let submitBtn = qDiv.querySelector(`#submit-${qId}`);
                      if (submitBtn) {
                          submitBtn.textContent = `Submitted (Attempt ${attempts}/3)`;
                          if (attempts >= 3) {
                              submitBtn.disabled = true;
                              submitBtn.classList.add('disabled');

                              // Disable all inputs
                              qDiv.querySelectorAll('input, textarea, button').forEach(el => {
                                  el.classList.add('disabled');
                                  el.disabled = true;
                              });

                              // Add max attempts message if not already there
                              if (!submitBtn.parentNode.querySelector('span[style*="red"]')) {
                                  let msg = document.createElement('span');
                                  msg.textContent = 'Max attempts reached (3/3)';
                                  msg.style.color = 'red';
                                  msg.style.marginLeft = '10px';
                                  submitBtn.parentNode.appendChild(msg);
                              }
                          }
                      }
                  }
              }

              // Re-apply MathJax if needed
              if (window.MathJax) {
                  MathJax.typesetPromise().catch((e) => console.log('MathJax error:', e));
              }
          }

          // Step 4: Sync functionality functions
          function mergeData(imported, target = classData) {
              for (let impUser in imported.users) {
                  if (!target.users[impUser]) {
                      target.users[impUser] = {answers: {}, reasons: {}, timestamps: {}, attempts: {}};
                  }
                  for (let fullQId in imported.users[impUser].answers) {
                      let localTs = target.users[impUser].timestamps[fullQId] || 0;
                      let impTs = imported.users[impUser].timestamps[fullQId] || 0;
                      if (impTs > localTs || !target.users[impUser].answers[fullQId]) {
                          target.users[impUser].answers[fullQId] = imported.users[impUser].answers[fullQId];
                          target.users[impUser].reasons[fullQId] = imported.users[impUser].reasons[fullQId] || '';
                          target.users[impUser].timestamps[fullQId] = impTs;
                          target.users[impUser].attempts[fullQId] = imported.users[impUser].attempts[fullQId];
                          console.log(`Merged ${fullQId} for ${impUser} (ts ${impTs})`);
                      }
                  }
              }
              localStorage.setItem('classData', JSON.stringify(target));
              loadProgress();
              return target;
          }

          function exportPersonal() {
              let personal = {exportTime: Date.now(), users: { [currentUsername]: classData.users[currentUsername] }};
              let blob = new Blob([JSON.stringify(personal, null, 2)], {type: 'application/json'});
              let url = URL.createObjectURL(blob);
              let a = document.createElement('a');
              a.href = url;
              a.download = `${currentUsername}_data.json`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              let status = document.getElementById('sync-status');
              if (status) {
                  status.textContent = 'Exported personal data';
                  setTimeout(() => status.textContent = '', 5000);
              }
          }

          function importClassData(event) {
              let file = event.target.files[0];
              if (!file) return;
              let reader = new FileReader();
              reader.onload = e => {
                  try {
                      let imported = JSON.parse(e.target.result);
                      mergeData(imported);
                      let status = document.getElementById('sync-status');
                      if (status) {
                          status.textContent = `Imported ${Object.keys(imported.users).length} users`;
                          setTimeout(() => status.textContent = '', 5000);
                      }
                  } catch(err) {
                      alert('Invalid JSON file');
                  }
              };
              reader.readAsText(file);
          }

          async function mergeImports(event) {
              let files = event.target.files;
              if (!files.length) return;
              let master = {users: {}};
              for (let file of Array.from(files)) {
                  let reader = new FileReader();
                  await new Promise(resolve => {
                      reader.onload = e => {
                          try {
                              let imp = JSON.parse(e.target.result);
                              mergeData(imp, master);
                          } catch(err) {
                              console.log('Invalid file:', file.name);
                          }
                          resolve();
                      };
                      reader.readAsText(file);
                  });
              }
              classData = mergeData(master, classData);
              let blob = new Blob([JSON.stringify({exportTime: Date.now(), users: classData.users}, null, 2)], {type: 'application/json'});
              let url = URL.createObjectURL(blob);
              let a = document.createElement('a');
              a.href = url;
              a.download = 'class_data.json';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              let status = document.getElementById('sync-status');
              if (status) {
                  status.textContent = `Merged ${files.length} files, ${Object.keys(classData.users).length} users total`;
                  setTimeout(() => status.textContent = '', 5000);
              }
          }

          // Step 5: Aggregation and View Functions
          
          // Initialize votes structure if not exists
          function initVotes() {
              if (!classData.users[currentUsername].votes) {
                  classData.users[currentUsername].votes = {};
              }
          }

          // Aggregate MCQ responses
          function aggregateMCQ(questionId) {
              const choiceCounts = {};
              let totalCount = 0;
              const contributors = [];

              // Count choices across all users
              for (let username in classData.users) {
                  const userAnswers = classData.users[username].answers;
                  if (userAnswers && userAnswers[questionId]) {
                      const answer = userAnswers[questionId];
                      const choice = answer.value || answer;
                      const reason = classData.users[username].reasons?.[questionId] || '';
                      const attempt = answer.attempt || 1;
                      
                      if (choice) {
                          choiceCounts[choice] = (choiceCounts[choice] || 0) + 1;
                          totalCount++;
                          contributors.push({
                              username: username,
                              choice: choice,
                              reason: reason,
                              attempt: attempt
                          });
                      }
                  }
              }

              return {
                  choiceCounts: choiceCounts,
                  totalCount: totalCount,
                  contributors: contributors
              };
          }

          // Aggregate FRQ responses
          function aggregateFRQ(questionId) {
              const responses = [];
              
              // Collect all responses
              for (let username in classData.users) {
                  const userAnswers = classData.users[username].answers;
                  if (userAnswers && userAnswers[questionId]) {
                      const answer = userAnswers[questionId];
                      const response = answer.value || answer;
                      const reason = classData.users[username].reasons?.[questionId] || '';
                      const attempt = answer.attempt || 1;
                      
                      if (response) {
                          // Calculate net votes for this response
                          let approves = 0;
                          let disapproves = 0;
                          const voteRecords = [];
                          
                          // Count votes from all users
                          for (let voter in classData.users) {
                              const voterVotes = classData.users[voter].votes;
                              if (voterVotes && voterVotes[questionId] && voterVotes[questionId][username]) {
                                  const vote = voterVotes[questionId][username];
                                  if (vote.vote === 'approve') {
                                      approves++;
                                  } else if (vote.vote === 'disapprove') {
                                      disapproves++;
                                  }
                                  if (vote.reason) {
                                      voteRecords.push({
                                          voter: voter,
                                          vote: vote.vote,
                                          reason: vote.reason
                                      });
                                  }
                              }
                          }
                          
                          responses.push({
                              username: username,
                              response: response,
                              reason: reason,
                              attempt: attempt,
                              approves: approves,
                              disapproves: disapproves,
                              netVotes: approves - disapproves,
                              voteRecords: voteRecords
                          });
                      }
                  }
              }
              
              // Sort by net votes (highest first)
              responses.sort((a, b) => b.netVotes - a.netVotes);
              
              return responses;
          }

          // Check consensus
          function checkConsensus(aggregateData, questionType) {
              if (questionType === 'multiple-choice') {
                  const { choiceCounts, totalCount } = aggregateData;
                  if (totalCount === 0) return { hasConsensus: false, message: 'No responses yet' };
                  
                  // Find mode (most common choice)
                  let mode = null;
                  let maxCount = 0;
                  for (let choice in choiceCounts) {
                      if (choiceCounts[choice] > maxCount) {
                          maxCount = choiceCounts[choice];
                          mode = choice;
                      }
                  }
                  
                  const percentage = maxCount / totalCount;
                  if (percentage >= 0.7) {
                      return {
                          hasConsensus: true,
                          message: `Consensus on ${mode} (${Math.round(percentage * 100)}%)`,
                          choice: mode,
                          percentage: percentage
                      };
                  } else {
                      return {
                          hasConsensus: false,
                          message: `No consensus yet (highest: ${mode} at ${Math.round(percentage * 100)}%)`,
                          choice: mode,
                          percentage: percentage
                      };
                  }
              } else {
                  // FRQ consensus based on net votes
                  const responses = aggregateData;
                  if (responses.length === 0) return { hasConsensus: false, message: 'No responses yet' };
                  
                  let totalVotes = 0;
                  let maxNetVotes = 0;
                  for (let resp of responses) {
                      totalVotes += resp.approves + resp.disapproves;
                      if (resp.netVotes > maxNetVotes) {
                          maxNetVotes = resp.netVotes;
                      }
                  }
                  
                  if (totalVotes === 0) return { hasConsensus: false, message: 'No votes yet - vote with reasons' };
                  
                  const netPercentage = maxNetVotes / totalVotes;
                  if (netPercentage >= 0.7) {
                      return {
                          hasConsensus: true,
                          message: `Emerging agreement (${Math.round(netPercentage * 100)}% net approval)`,
                          percentage: netPercentage
                      };
                  } else {
                      return {
                          hasConsensus: false,
                          message: `Low agreement - vote with reasons`,
                          percentage: netPercentage
                      };
                  }
              }
          }

          // Toggle view section
          window.toggleView = function(questionId) {
              const viewSection = document.getElementById(`view-section-${questionId}`);
              if (viewSection) {
                  viewSection.classList.toggle('show');
                  if (viewSection.classList.contains('show')) {
                      renderView(questionId);
                  }
              }
          }

          // Render view for a question
          function renderView(questionId) {
              const viewSection = document.getElementById(`view-section-${questionId}`);
              if (!viewSection) return;
              
              // Determine question type
              const qDiv = document.querySelector(`[data-question-id="${questionId}"]`);
              if (!qDiv) return;
              
              const questionType = qDiv.querySelector('input[type="radio"]') ? 'multiple-choice' : 'free-response';
              
              // Check for pre/post pairs
              const isPrePost = questionId.includes('_pre') || questionId.includes('_post');
              if (isPrePost) {
                  const baseId = questionId.replace(/_pre|_post/, '');
                  const preId = baseId + '_pre';
                  const postId = baseId + '_post';
                  
                  // Check if both exist
                  const preExists = classData.users[currentUsername]?.answers?.[preId];
                  const postExists = classData.users[currentUsername]?.answers?.[postId];
                  
                  if (preExists && postExists) {
                      // Render side-by-side
                      viewSection.innerHTML = `
                          <div class="side-by-side">
                              <div>
                                  <h4>Pre-Assessment</h4>
                                  ${renderSingleView(preId, questionType)}
                              </div>
                              <div>
                                  <h4>Post-Assessment</h4>
                                  ${renderSingleView(postId, questionType)}
                              </div>
                          </div>
                      `;
                      return;
                  }
              }
              
              // Render single view
              viewSection.innerHTML = renderSingleView(questionId, questionType);
          }

          // Render single view (for reuse in side-by-side)
          function renderSingleView(questionId, questionType) {
              let html = '';
              
              if (questionType === 'multiple-choice') {
                  const aggregateData = aggregateMCQ(questionId);
                  
                  // Check if self-only
                  if (aggregateData.totalCount <= 1) {
                      html += '<div class="preview-note">Preview – sync peers for class view</div>';
                  }
                  
                  // Create dotplot
                  html += '<div class="dotplot-container">';
                  html += `<canvas id="dotplot-${questionId}" width="400" height="200"></canvas>`;
                  html += '</div>';
                  
                  // Check consensus
                  const consensus = checkConsensus(aggregateData, questionType);
                  if (consensus.hasConsensus) {
                      html += `<div class="consensus">${consensus.message}</div>`;
                  } else {
                      html += `<div class="low-consensus">${consensus.message}</div>`;
                  }
                  
                  // Contributors list
                  html += '<div class="contributors-list">';
                  html += '<h4>Contributors:</h4>';
                  for (let contributor of aggregateData.contributors) {
                      html += `<div class="contributor-item">`;
                      html += `<strong>${contributor.username}</strong> chose <strong>${contributor.choice}</strong> (Attempt ${contributor.attempt})`;
                      if (contributor.reason) {
                          html += `<br>Reason: <em>${contributor.reason}</em>`;
                      }
                      html += '</div>';
                  }
                  html += '</div>';
                  
                  // Schedule dotplot rendering
                  setTimeout(() => renderDotplot(questionId, aggregateData), 100);
                  
              } else {
                  // FRQ view
                  const responses = aggregateFRQ(questionId);
                  
                  // Check if self-only
                  if (responses.length <= 1) {
                      html += '<div class="preview-note">Preview – sync peers for class view</div>';
                  }
                  
                  // Check consensus
                  const consensus = checkConsensus(responses, questionType);
                  if (consensus.hasConsensus) {
                      html += `<div class="consensus">${consensus.message}</div>`;
                  } else {
                      html += `<div class="low-consensus">${consensus.message}</div>`;
                  }
                  
                  // Responses list
                  html += '<ul style="list-style: none; padding: 0;">';
                  for (let resp of responses) {
                      const netClass = resp.netVotes > 0 ? 'positive' : (resp.netVotes < 0 ? 'negative' : 'neutral');
                      html += `<li class="response-li">`;
                      html += `<strong>${resp.username}</strong> (Attempt ${resp.attempt})`;
                      html += `<span class="net-votes ${netClass}">Net: ${resp.netVotes} (↑${resp.approves} ↓${resp.disapproves})</span>`;
                      html += `<div style="margin: 8px 0;">${resp.response}</div>`;
                      if (resp.reason) {
                          html += `<div style="font-style: italic; color: #666;">Reason: ${resp.reason}</div>`;
                      }
                      
                      // Voting buttons
                      html += `<div style="margin-top: 8px;">`;
                      html += `<button class="vote-btn approve-btn" onclick="vote('${questionId}', '${resp.username}', 'approve')">Approve</button>`;
                      html += `<button class="vote-btn disapprove-btn" onclick="vote('${questionId}', '${resp.username}', 'disapprove')">Disapprove</button>`;
                      html += `<input type="text" class="vote-reason-input" id="vote-reason-${questionId}-${resp.username}" 
                               placeholder="Optional: Why this vote?" onblur="saveVoteReason('${questionId}', '${resp.username}')">`;
                      html += '</div>';
                      
                      // Display vote records
                      if (resp.voteRecords.length > 0) {
                          html += '<div style="margin-top: 8px;">';
                          for (let record of resp.voteRecords) {
                              const voteText = record.vote === 'approve' ? 'Approved' : 'Disapproved';
                              html += `<div class="vote-record">${voteText} by ${record.voter}: "${record.reason}"</div>`;
                          }
                          html += '</div>';
                      }
                      
                      html += '</li>';
                  }
                  html += '</ul>';
              }
              
              return html;
          }

          // Render dotplot using Chart.js
          function renderDotplot(questionId, aggregateData) {
              const canvas = document.getElementById(`dotplot-${questionId}`);
              if (!canvas) return;
              
              const ctx = canvas.getContext('2d');
              
              // Prepare data for Chart.js horizontal bar chart (acting as dotplot)
              const choices = Object.keys(aggregateData.choiceCounts).sort();
              const counts = choices.map(c => aggregateData.choiceCounts[c]);
              
              new Chart(ctx, {
                  type: 'bar',
                  data: {
                      labels: choices,
                      datasets: [{
                          label: 'Responses',
                          data: counts,
                          backgroundColor: '#36A2EB',
                          borderColor: '#36A2EB',
                          borderWidth: 1
                      }]
                  },
                  options: {
                      indexAxis: 'y',
                      responsive: true,
                      maintainAspectRatio: false,
                      scales: {
                          x: {
                              beginAtZero: true,
                              ticks: {
                                  stepSize: 1
                              },
                              title: {
                                  display: true,
                                  text: 'Count'
                              }
                          },
                          y: {
                              title: {
                                  display: true,
                                  text: 'Choice'
                              }
                          }
                      },
                      plugins: {
                          legend: {
                              display: false
                          },
                          datalabels: {
                              display: true,
                              color: 'black',
                              anchor: 'end',
                              align: 'right',
                              formatter: (value) => value
                          }
                      }
                  }
              });
          }

          // Vote function
          window.vote = function(questionId, targetUser, voteType) {
              if (!currentUsername) {
                  alert('Please enter your username first!');
                  return;
              }
              
              initVotes();
              
              // Initialize vote structure
              if (!classData.users[currentUsername].votes[questionId]) {
                  classData.users[currentUsername].votes[questionId] = {};
              }
              
              // Show reason input
              const reasonInput = document.getElementById(`vote-reason-${questionId}-${targetUser}`);
              if (reasonInput) {
                  reasonInput.classList.add('show');
              }
              
              // Save vote
              classData.users[currentUsername].votes[questionId][targetUser] = {
                  vote: voteType,
                  reason: '',
                  timestamp: Date.now()
              };
              
              // Save to localStorage
              try {
                  localStorage.setItem('classData', JSON.stringify(classData));
              } catch(e) {
                  console.log("Storage quota exceeded—data not saved");
              }
              
              // Re-render view
              renderView(questionId);
          }

          // Save vote reason
          window.saveVoteReason = function(questionId, targetUser) {
              const reasonInput = document.getElementById(`vote-reason-${questionId}-${targetUser}`);
              if (!reasonInput) return;
              
              const reason = reasonInput.value.trim();
              
              if (classData.users[currentUsername].votes?.[questionId]?.[targetUser]) {
                  classData.users[currentUsername].votes[questionId][targetUser].reason = reason;
                  classData.users[currentUsername].votes[questionId][targetUser].timestamp = Date.now();
                  
                  // Save to localStorage
                  try {
                      localStorage.setItem('classData', JSON.stringify(classData));
                  } catch(e) {
                      console.log("Storage quota exceeded—data not saved");
                  }
                  
                  // Re-render view
                  renderView(questionId);
              }
          }


          // Theme management
          function initTheme() {
              const savedTheme = localStorage.getItem('quizTheme') || 'light';
              currentTheme = savedTheme;
              applyTheme(savedTheme);
          }

          function applyTheme(theme) {
              const body = document.body;
              const themeButton = document.querySelector('.theme-toggle');

              if (theme === 'dark') {
                  body.classList.add('dark-theme');
                  themeButton.textContent = '☀️';
              } else {
                  body.classList.remove('dark-theme');
                  themeButton.textContent = '🌙';
              }

              currentTheme = theme;
              localStorage.setItem('quizTheme', theme);

              // Re-render charts with appropriate theme
              if (window.lastLoadedData) {
                  clearQuiz(true); // Silent clear
                  renderQuiz(window.lastLoadedData);
              }
          }

          function toggleTheme() {
              const newTheme = currentTheme === 'light' ? 'dark' : 'light';
              applyTheme(newTheme);
              buttonTones.click();
          }

          function isDarkMode() {
              return currentTheme === 'dark';
          }

          function generateChartColors(count) {
              const lightColors = [
                  '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                  '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF',
                  '#4BC0C0', '#FF6384', '#36A2EB', '#FFCE56'
              ];

              const darkColors = [
                  '#FF8FA3', '#5BC0EB', '#FFE066', '#6BE6E6',
                  '#B366FF', '#FFB366', '#FF8FA3', '#E9EBEF',
                  '#6BE6E6', '#FF8FA3', '#5BC0EB', '#FFE066'
              ];

              const colors = isDarkMode() ? darkColors : lightColors;
              return colors.slice(0, count);
          }

          function getGridColor() {
              return isDarkMode() ? '#555555' : '#e9ecef';
          }

          function getScatterPointColor() {
              return isDarkMode() ? '#5BC0EB' : '#36A2EB';
          }

          function getTextColor() {
              return isDarkMode() ? '#e0e0e0' : '#333333';
          }

          function showMessage(message, type = 'info') {
              const messageArea = document.getElementById('messageArea');
              const messageClass = type === 'error' ? 'error' : 'success';
              messageArea.innerHTML = `<div class="${messageClass}">${message}</div>`;

              // Play appropriate tone
              if (type === 'error') {
                  buttonTones.error();
              } else {
                  buttonTones.success();
              }

              // Clear message after 5 seconds
              setTimeout(() => {
                  messageArea.innerHTML = '';
              }, 5000);
          }

          function showStats(questions) {
              const totalQuestions = questions.length;
              const mcQuestions = questions.filter(q => q.type === 'multiple-choice').length;
              const frQuestions = questions.filter(q => q.type === 'free-response').length;
              const hasCharts = questions.filter(q => q.attachments && q.attachments.chartType).length;
              const hasTables = questions.filter(q => q.attachments && q.attachments.table).length;

              const barCharts = questions.filter(q => q.attachments && q.attachments.chartType === 'bar').length;
              const histograms = questions.filter(q => q.attachments && q.attachments.chartType === 'histogram').length;
              const pieCharts = questions.filter(q => q.attachments && q.attachments.chartType === 'pie').length;
              const scatterPlots = questions.filter(q => q.attachments && q.attachments.chartType === 'scatter').length;
              const dotplots = questions.filter(q => q.attachments && q.attachments.chartType === 'dotplot').length;
              const boxplots = questions.filter(q => q.attachments && q.attachments.chartType === 'boxplot').length;

              let statsHtml = `
                  <div class="stats">
                      <strong>📊 Quiz Statistics:</strong><br>
                      Total Questions: ${totalQuestions} | 
                      Multiple Choice: ${mcQuestions} | 
                      Free Response: ${frQuestions}<br>
                      Charts: ${hasCharts} | 
                      Tables: ${hasTables}
              `;

              if (hasCharts > 0) {
                  statsHtml += `<br>Chart Types: `;
                  const chartTypes = [];
                  if (barCharts > 0) chartTypes.push(`Bar: ${barCharts}`);
                  if (histograms > 0) chartTypes.push(`Histogram: ${histograms}`);
                  if (pieCharts > 0) chartTypes.push(`Pie: ${pieCharts}`);
                  if (scatterPlots > 0) chartTypes.push(`Scatter: ${scatterPlots}`);
                  if (dotplots > 0) chartTypes.push(`Dotplot: ${dotplots}`);
                  if (boxplots > 0) chartTypes.push(`Boxplot: ${boxplots}`);
                  statsHtml += chartTypes.join(' | ');
              }

              statsHtml += `</div>`;
              document.getElementById('statsArea').innerHTML = statsHtml;
          }

          function clearQuiz(silent = false) {
              // Destroy all chart instances
              chartInstances.forEach(chart => chart.destroy());
              chartInstances = [];

              // Clear containers
              document.getElementById('questionsContainer').innerHTML = '';
              document.getElementById('statsArea').innerHTML = '';
              if (!silent) {
                  document.getElementById('messageArea').innerHTML = '';
                  document.getElementById('jsonInput').value = '';
              }

              // Hide and reset context finder
              const contextDiv = document.getElementById('contextFinder');
              if (contextDiv) {
                  contextDiv.style.display = 'none';
                  contextDiv.innerHTML = '';
              }
              if (contextObserver) {
                  contextObserver.disconnect();
              }

              if (!silent) {
                  showMessage('Quiz cleared successfully', 'success');
                  buttonTones.clear();
              }
          }

          function loadFromFile() {
              const fileInput = document.getElementById('fileInput');
              const file = fileInput.files[0];

              if (!file) {
                  showMessage('Please select a file first', 'error');
                  return;
              }

              const reader = new FileReader();
              reader.onload = function(e) {
                  try {
                      const jsonText = e.target.result;
                      const cleanedJson = cleanJsonText(jsonText);
                      const data = JSON.parse(cleanedJson);
                      renderQuiz(data);
                      showMessage('Quiz loaded successfully from file!', 'success');
                      buttonTones.load();
                  } catch (error) {
                      showMessage('Error parsing JSON: ' + error.message, 'error');
                  }
              };
              reader.readAsText(file);
          }

          function loadFromTextarea() {
              const jsonInput = document.getElementById('jsonInput').value.trim();

              if (!jsonInput) {
                  showMessage('Please enter JSON data in the textarea', 'error');
                  return;
              }

              try {
                  const cleanedJson = cleanJsonText(jsonInput);
                  const data = JSON.parse(cleanedJson);
                  renderQuiz(data);
                  showMessage('Quiz loaded successfully from textarea!', 'success');
                  buttonTones.load();
              } catch (error) {
                  showMessage('Error parsing JSON: ' + error.message, 'error');
              }
          }

          function loadDebugData() {
              const debugData = [
                  {
                      "id": "DEBUG-MC-01",
                      "type": "multiple-choice",
                      "prompt": "A researcher collects data on \\(n = 50\\) students. What is the probability that the sample mean \\(\\bar{x}\\) falls within one standard error of the population mean \\(\\mu\\)?",
                      "choices": [
                          {"key": "A", "value": "Approximately 68%"},
                          {"key": "B", "value": "Approximately 95%"},
                          {"key": "C", "value": "Approximately 99.7%"},
                          {"key": "D", "value": "Cannot be determined"}
                      ],
                      "attachments": {
                          "chartType": "histogram",
                          "data": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 9],
                          "title": "Sample Distribution",
                          "xLabel": "Value",
                          "yLabel": "Frequency",
                          "bins": 9
                      }
                  },
                  {
                      "id": "DEBUG-FR-01",
                      "type": "free-response",
                      "prompt": "A factory produces widgets with a mean weight of \\(\\mu = 100\\) grams and standard deviation \\(\\sigma = 5\\) grams. A quality control inspector randomly selects 25 widgets.",
                      "attachments": {
                          "table": {
                              "headers": ["Sample", "Mean (g)", "Std Dev (g)", "Min (g)", "Max (g)"],
                              "rows": [
                                  ["1", "99.2", "4.8", "89.5", "108.3"],
                                  ["2", "101.5", "5.2", "91.2", "111.8"],
                                  ["3", "100.3", "4.9", "90.1", "109.5"],
                                  ["4", "98.7", "5.5", "87.3", "110.2"],
                                  ["5", "100.8", "4.7", "92.4", "108.9"]
                              ]
                          }
                      }
                  },
                  {
                      "id": "DEBUG-CHART-01",
                      "type": "multiple-choice",
                      "prompt": "Based on the scatter plot below, what type of relationship exists between the variables?",
                      "choices": [
                          {"key": "A", "value": "Strong positive linear"},
                          {"key": "B", "value": "Strong negative linear"},
                          {"key": "C", "value": "No relationship"},
                          {"key": "D", "value": "Non-linear relationship"}
                      ],
                      "attachments": {
                          "chartType": "scatter",
                          "xData": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                          "yData": [2.1, 3.9, 6.1, 7.8, 10.2, 11.9, 14.1, 15.8, 18.2, 19.9],
                          "title": "Relationship Between X and Y",
                          "xLabel": "X Variable",
                          "yLabel": "Y Variable",
                          "showTrendline": true
                      }
                  }
              ];

              document.getElementById('jsonInput').value = JSON.stringify(debugData, null, 2);
              renderQuiz(debugData);
              showMessage('Debug data loaded with histogram, table, and scatter plot examples!', 'success');
              buttonTones.load();
          }

          // COMPLETE CHART RENDERING FROM ORIGINAL quiz_renderer.html
          function renderChart(chartData, questionId) {
              const chartId = `chart-${questionId}`;
              const config = chartData.chartConfig || {};

              // Use the chart's title if available, otherwise use the chart type
              const chartTitle = chartData.title ?
                  chartData.title :
                  (config.description ?
                      `📊 ${chartData.chartType.toUpperCase()} CHART` :
                      `📊 ${chartData.chartType.toUpperCase()} CHART`);

              // Allow a chart to request full horizontal space when rendered inside a "multiple-charts-container"
              const containerStyle = chartData.fullWidth ? 'style="flex:0 0 100%; max-width:100%; width:100%;"' : '';

              let chartHtml = `
                  <div class="chart-container" ${containerStyle}>
                      <div class="chart-title">${chartTitle}</div>
                      ${config.description ? `<div style="font-size: 0.9em; color: #666; text-align: center; margin-bottom: 10px; font-style: italic;">${config.description}</div>` : 
  ''}
                      <div class="chart-canvas">
                          <canvas id="${chartId}"></canvas>
                      </div>
                  </div>
              `;

              // Return HTML first, then we'll create the chart after the DOM is updated
              setTimeout(() => {
                  const canvas = document.getElementById(chartId);
                  if (!canvas) return;

                  const ctx = canvas.getContext('2d');

                  if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
                      // Ensure every segment in a stacked / segmented bar gets its own visually distinct color
                      // 1. Compute one shared palette sized to the total number of series.
                      // 2. Pick the palette entry matching the series index (wrap-around safety for very large N).
                      const colorPalette = generateChartColors(chartData.series.length);

                      const datasets = chartData.series.map((series, index) => {
                          const color = colorPalette[index % colorPalette.length] || '#36A2EB';
                          return {
                              label: series.name,
                              data: series.values,
                              backgroundColor: color,
                              borderColor: color,
                              borderWidth: 1
                          };
                      });

                      // Use chartConfig if available, otherwise use defaults
                      const yAxisConfig = config.yAxis || {};
                      const xAxisConfig = config.xAxis || {};

                      // Handle grid lines - support both old and new formats
                      let showHorizontalGrid = true;
                      let showVerticalGrid = false;

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              // Old format: gridLines: true/false
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = false;
                          } else if (typeof config.gridLines === 'object') {
                              // New format: gridLines: {horizontal: true, vertical: false}
                              showHorizontalGrid = config.gridLines.horizontal !== false;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Configure bar spacing - gaps for bar charts, no gaps for histograms
                      const isHistogram = chartData.chartType === 'histogram';
                      const categoryPercentage = isHistogram ? 1.0 : 0.8;
                      const barPercentage = isHistogram ? 1.0 : 0.9;

                      // NEW: Detect orientation for bar charts (default to vertical)
                      const orientation = config.orientation || 'vertical';
                      const isHorizontalBar = orientation === 'horizontal';

                      // NEW: Detect if bars should be stacked (applies only to bar charts)
                      const isStacked = config.stacked === true || config.stacked === 'true';

                      // Handle labels based on orientation - support both xLabels and yLabels
                      let displayLabels = isHorizontalBar ? (chartData.yLabels || chartData.xLabels) : (chartData.xLabels || chartData.yLabels);

                      // Preserve existing labelType overrides
                      if (xAxisConfig.labelType === 'upperBound' && xAxisConfig.labels) {
                          displayLabels = xAxisConfig.labels;
                      } else if (xAxisConfig.labelType === 'range' && chartData.xLabels) {
                          displayLabels = chartData.xLabels;
                      } else if (xAxisConfig.labelType === 'lowerBound') {
                          displayLabels = xAxisConfig.labels || chartData.xLabels;
                      }

                      const chart = new Chart(ctx, {
                          type: 'bar',
                          data: {
                              labels: displayLabels,
                              datasets: datasets
                          },
                          options: {
                              indexAxis: isHorizontalBar ? 'y' : 'x',
                              responsive: true,
                              maintainAspectRatio: false,
                              categoryPercentage: categoryPercentage,
                              barPercentage: barPercentage,
                              scales: isHorizontalBar ? {
                                  x: {
                                      beginAtZero: xAxisConfig.min !== undefined ? (xAxisConfig.min === 0) : true,
                                      min: xAxisConfig.min,
                                      max: xAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      stacked: isStacked,
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          maxTicksLimit: xAxisConfig.tickInterval ? undefined : 10,
                                          precision: 2,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      title: {
                                          display: true,
                                          text: yAxisConfig.title || 'Category',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          color: getTextColor()
                                      },
                                      offset: true
                                  }
                              } : {
                                  y: {
                                      beginAtZero: yAxisConfig.min !== undefined ? (yAxisConfig.min === 0) : true,
                                      min: yAxisConfig.min,
                                      max: yAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: yAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor(),
                                          lineWidth: 1,
                                          drawBorder: true,
                                          drawOnChartArea: true,
                                          drawTicks: !yAxisConfig.hideTicks
                                      },
                                      stacked: isStacked,
                                      ticks: {
                                          stepSize: yAxisConfig.tickInterval,
                                          maxTicksLimit: yAxisConfig.tickInterval ? undefined : 10,
                                          precision: 2,
                                          color: getTextColor(),
                                          display: !yAxisConfig.hideTicks,
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              if (yAxisConfig.hideTicks) return '';
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (yAxisConfig.tickInterval) {
                                                  const step = yAxisConfig.tickInterval;
                                                  const min = yAxisConfig.min !== undefined ? yAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  x: {
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Category',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      stacked: isStacked,
                                      ticks: {
                                          color: getTextColor()
                                      },
                                      offset: true
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: datasets.length > 1,
                                      labels: {
                                          color: getTextColor()
                                      }
                                  },
                                  // Enable data labels for bar/histogram charts when requested via chartConfig.showPointLabels
                                  datalabels: {
                                      display: config.showPointLabels === true,
                                      color: getTextColor(),
                                      anchor: isHorizontalBar ? 'center' : 'end',
                                      align: isHorizontalBar ? 'right' : 'top',
                                      formatter: (value) => value
                                  }
                              }
                          }
                      });
                      chartInstances.push(chart);

                  } else if (chartData.chartType === 'pie') {
                      const seriesData = chartData.series[0].values;
                      const labels = seriesData.map(item => item.name);
                      const values = seriesData.map(item => item.value);

                      const chart = new Chart(ctx, {
                          type: 'pie',
                          data: {
                              labels: labels,
                              datasets: [{
                                  data: values,
                                  backgroundColor: generateChartColors(values.length),
                                  borderWidth: 2,
                                  borderColor: isDarkMode() ? '#2d2d2d' : '#fff'
                              }]
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              plugins: {
                                  legend: {
                                      position: 'bottom',
                                      labels: {
                                          padding: 20,
                                          usePointStyle: true,
                                          color: getTextColor()
                                      }
                                  },
                                  // Optional data labels for pie charts (percentages) when chartConfig.showPointLabels is true
                                  datalabels: {
                                      display: (config.showPointLabels === true),
                                      color: getTextColor(),
                                      formatter: function(value, context) {
                                          const total = values.reduce((a, b) => a + b, 0);
                                          const percentage = ((value / total) * 100).toFixed(1);
                                          return percentage + '%';
                                      }
                                  },
                                  tooltip: {
                                      callbacks: {
                                          label: function(context) {
                                              const total = values.reduce((a, b) => a + b, 0);
                                              const percentage = ((context.parsed / total) * 100).toFixed(1);
                                              return `${context.label}: ${context.parsed} (${percentage}%)`;
                                          }
                                      }
                                  }
                              }
                          }
                      });
                      chartInstances.push(chart);

                  } else if (chartData.chartType === 'scatter') {
                      const config = chartData.chartConfig || {};
                      const xAxisConfig = config.xAxis || {};
                      const yAxisConfig = config.yAxis || {};

                      // Handle grid lines - support both old and new formats
                      let showHorizontalGrid = true;
                      let showVerticalGrid = true; // Scatter plots often show both grids

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              // Old format: gridLines: true/false
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = config.gridLines;
                          } else if (typeof config.gridLines === 'object') {
                              // New format: gridLines: {horizontal: true, vertical: false}
                              showHorizontalGrid = config.gridLines.horizontal === true;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Build primary dataset (scatter points)
                      const datasets = [{
                          label: 'Data Points',
                          data: chartData.points,
                          backgroundColor: getScatterPointColor(),
                          borderColor: getScatterPointColor(),
                          pointRadius: 4,
                          pointHoverRadius: 6
                      }];

                      // Determine if we should render point labels
                      const hasPointLabels = (chartData.points || []).some(pt => pt.label !== undefined);

                      // --------------------------------------------------
                      // Optional regression line (least-squares)            <-- ADD
                      // --------------------------------------------------
                      if (config.regressionLine) {
                          const pts = chartData.points || [];
                          if (Array.isArray(pts) && pts.length >= 2) {
                              // Compute least-squares slope and intercept
                              let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
                              pts.forEach(p => {
                                  sumX += p.x;
                                  sumY += p.y;
                                  sumXY += p.x * p.y;
                                  sumXX += p.x * p.x;
                              });
                              const n = pts.length;
                              const denominator = n * sumXX - sumX * sumX;
                              if (denominator !== 0) {
                                  const slope = (n * sumXY - sumX * sumY) / denominator;
                                  const intercept = (sumY - slope * sumX) / n;

                                  // Determine the horizontal span for the line
                                  let minX = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : undefined;
                                  let maxX = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : undefined;
                                  if (minX === undefined || maxX === undefined) {
                                      const xs = pts.map(p => p.x);
                                      if (minX === undefined) minX = Math.min(...xs);
                                      if (maxX === undefined) maxX = Math.max(...xs);
                                  }

                                  // Style overrides (optional)
                                  const regColor = config.regressionLineColor || getTextColor();
                                  const regDash  = config.regressionLineDash  || [];

                                  datasets.push({
                                      label: 'Regression Line',
                                      type: 'line',
                                      data: [
                                          { x: minX, y: slope * minX + intercept },
                                          { x: maxX, y: slope * maxX + intercept }
                                      ],
                                      borderColor: regColor,
                                      borderDash: regDash,
                                      borderWidth: 2,
                                      fill: false,
                                      pointRadius: 0,
                                      tension: 0,
                                      order: 0
                                  });
                              }
                          }
                      }

                      // --------------------------------------------------
                      // Optional reference line at y = 0 (useful for residual plots)
                      // --------------------------------------------------
                      if (config.referenceLineAtZero) {
                          // Determine horizontal span of the scatter data (fallback to axis min/max)
                          let minX = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : undefined;
                          let maxX = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : undefined;
                          if (minX === undefined || maxX === undefined) {
                              const xs = chartData.points.map(p => p.x);
                              if (minX === undefined) minX = Math.min(...xs);
                              if (maxX === undefined) maxX = Math.max(...xs);
                          }

                          datasets.push({
                              label: 'Reference Line y = 0',
                              type: 'line',
                              data: [
                                  { x: minX, y: 0 },
                                  { x: maxX, y: 0 }
                              ],
                              borderColor: '#CC0000',
                              borderDash: [6, 4],
                              borderWidth: 2,
                              fill: false,
                              pointRadius: 0,
                              order: 0
                          });
                      }

                      const chart = new Chart(ctx, {
                          type: 'scatter',
                          data: {
                              datasets: datasets
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xAxisConfig.min,
                                      max: xAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'X Variable',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      min: yAxisConfig.min,
                                      max: yAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: yAxisConfig.title || 'Y Variable',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: yAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (yAxisConfig.tickInterval) {
                                                  const step = yAxisConfig.tickInterval;
                                                  const min = yAxisConfig.min !== undefined ? yAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: false
                                  },
                                  datalabels: {
                                      display: (ctx) => {
                                          const d = ctx.dataset.data[ctx.dataIndex];
                                          // Show label if point has 'label' or global chartConfig requests labels
                                          return (d && d.label !== undefined) || config.showPointLabels === true;
                                      },
                                      align: 'top',
                                      anchor: 'center',
                                      color: getTextColor(),
                                      formatter: (value) => {
                                          // If value has explicit label use that, otherwise display y
                                          if (value.label !== undefined) return value.label;
                                          if (config.showPointLabels === true) {
                                              return `(${value.x}, ${value.y})`;
                                          }
                                          return '';
                                      },
                                      font: {
                                          size: 12
                                      }
                                  }
                              }
                          }
                      });
                      chartInstances.push(chart);

                      // Add point label plugin AFTER chart creation to ensure meta is available
                      if (false && (hasPointLabels || config.showPointLabels)) {
                          // Create inline plugin specific to this chart instance
                          const labelPlugin = {
                              id: 'scatterPointLabels',
                              afterDatasetsDraw: (c) => {
                                  if (c !== chart) return; // Only draw for this chart instance
                                  const ctx = c.ctx;
                                  ctx.save();
                                  c.data.datasets.forEach((ds, dsi) => {
                                      // Only annotate the point dataset (assumed first) or explicitly marked datasets
                                      if (dsi !== 0) return;
                                      const meta = c.getDatasetMeta(dsi);
                                      meta.data.forEach((elem, idx) => {
                                          const pointData = ds.data[idx];
                                          const lbl = pointData && pointData.label;
                                          if (lbl === undefined) return;
                                          const {x, y} = elem.getCenterPoint();
                                          ctx.fillStyle = getTextColor();
                                          ctx.font = '12px sans-serif';
                                          ctx.textAlign = 'center';
                                          ctx.textBaseline = 'bottom';
                                          ctx.fillText(lbl, x, y - 6);
                                      });
                                  });
                                  ctx.restore();
                              }
                          };
                          chart.options.plugins = chart.options.plugins || [];
                          chart.options.plugins.push(labelPlugin);
                          chart.update();
                      }

                  } else if (chartData.chartType === 'dotplot') {
                      const config = chartData.chartConfig || {};
                      const xAxisConfig = config.xAxis || {};

                      // Handle grid lines - dotplots typically have no grid lines
                      let showHorizontalGrid = false;
                      let showVerticalGrid = false;

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = config.gridLines;
                          } else if (typeof config.gridLines === 'object') {
                              showHorizontalGrid = config.gridLines.horizontal === true;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Convert raw values to frequency data for dotplot
                      const valueFrequency = {};
                      chartData.values.forEach(value => {
                          valueFrequency[value] = (valueFrequency[value] || 0) + 1;
                      });

                      // Create stacked dots data
                      const dotplotData = [];
                      for (const [value, frequency] of Object.entries(valueFrequency)) {
                          for (let i = 1; i <= frequency; i++) {
                              dotplotData.push({
                                  x: parseFloat(value),
                                  y: i
                              });
                          }
                      }

                      // Find max frequency for y-axis
                      const maxFrequency = Math.max(...Object.values(valueFrequency));

                      // Allow caller to set dot radius (default 4)
                      const dotRadius = (config.dotRadius !== undefined ? config.dotRadius : 4);

                      const chart = new Chart(ctx, {
                          type: 'scatter',
                          data: {
                              datasets: [{
                                  label: 'Data Points',
                                  data: dotplotData,
                                  backgroundColor: getScatterPointColor(),
                                  borderColor: getScatterPointColor(),
                                  pointRadius: dotRadius,
                                  pointHoverRadius: dotRadius + 2,
                                  showLine: false
                              }]
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xAxisConfig.min,
                                      max: xAxisConfig.max,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      type: 'linear',
                                      min: 0,
                                      max: maxFrequency + 1,
                                      title: {
                                          display: false  // Dotplots don't typically show y-axis labels
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          display: false,  // Hide y-axis tick labels
                                          stepSize: 1
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: false
                                  },
                                  datalabels: {
                                      display: () => config.showPointLabels === true,
                                      align: 'top',
                                      anchor: 'center',
                                      color: getTextColor(),
                                      formatter: (value) => value.y,
                                      font: { size: 12 }
                                  },
                                  tooltip: {
                                      callbacks: {
                                          title: function(context) {
                                              return `Value: ${context[0].parsed.x}`;
                                          },
                                          label: function(context) {
                                              return `Count: ${valueFrequency[context.parsed.x]}`;
                                          }
                                      }
                                  }
                              }
                          }
                      });
                       chartInstances.push(chart);

                      // Adjust chart height so stacked dots appear closer (rough heuristic)
                      const minHeight = 120;
                      const desiredHeight = Math.max(minHeight, (dotRadius * 2 + 4) * (maxFrequency + 1));
                      canvas.parentElement.style.height = desiredHeight + 'px';


                  } else if (chartData.chartType === 'boxplot') {
                      const config = chartData.chartConfig || {};
                      const xAxisConfig = config.xAxis || {};
                      const boxplotData = config.boxplotData || {};

                      // Handle grid lines
                      let showHorizontalGrid = false;
                      let showVerticalGrid = false;

                      if (config.gridLines !== undefined) {
                          if (typeof config.gridLines === 'boolean') {
                              showHorizontalGrid = config.gridLines;
                              showVerticalGrid = config.gridLines;
                          } else if (typeof config.gridLines === 'object') {
                              showHorizontalGrid = config.gridLines.horizontal === true;
                              showVerticalGrid = config.gridLines.vertical === true;
                          }
                      }

                      // Handle multiple boxplots (array) or single boxplot (object)
                      const boxplots = Array.isArray(boxplotData) ? boxplotData : [boxplotData];

                      // Check orientation from config (default to horizontal)
                      const orientation = config.orientation || 'horizontal';
                      const isHorizontal = orientation === 'horizontal';

                      // Find overall min/max for axis scaling
                      let overallMin = Infinity;
                      let overallMax = -Infinity;

                      boxplots.forEach(boxplot => {
                          const { Q1, Q3, median, min, max, whiskerMin, whiskerMax, outliers } = boxplot;

                          // Support both old format (min/max) and new format (whiskerMin/whiskerMax + outliers)
                          const actualWhiskerMin = whiskerMin !== undefined ? whiskerMin : min;
                          const actualWhiskerMax = whiskerMax !== undefined ? whiskerMax : max;
                          const actualOutliers = outliers || [];

                          // Calculate overall range including outliers
                          const allValues = [actualWhiskerMin, actualWhiskerMax, ...actualOutliers];
                          overallMin = Math.min(overallMin, Math.min(...allValues));
                          overallMax = Math.max(overallMax, Math.max(...allValues));
                                           });

                      // Create boxplot visualization with orientation support
                      let datasets = [];

                      // Generate colors for multiple boxplots
                      const boxplotColors = generateChartColors(boxplots.length);

                      boxplots.forEach((boxplot, index) => {
                          const { Q1, Q3, median, min, max, whiskerMin, whiskerMax, outliers, name } = boxplot;

                          // Support both old format (min/max) and new format (whiskerMin/whiskerMax + outliers)
                          const actualWhiskerMin = whiskerMin !== undefined ? whiskerMin : min;
                          const actualWhiskerMax = whiskerMax !== undefined ? whiskerMax : max;
                          const actualOutliers = outliers || [];

                          // Calculate position for multiple boxplots
                          const boxplotSpacing = 0.8; // Space between boxplots
                          const yPos = isHorizontal ? (index - (boxplots.length - 1) / 2) * boxplotSpacing : 0;
                          const xPos = !isHorizontal ? (index - (boxplots.length - 1) / 2) * boxplotSpacing : 0;

                          const color = boxplotColors[index];
                          const boxplotName = name || `Boxplot ${index + 1}`;

                          if (isHorizontal) {
                              // Horizontal boxplot
                              datasets.push(
                                  // Median line (vertical in horizontal boxplot)
                                  {
                                      label: `${boxplotName} Median`,
                                      data: [{ x: median, y: yPos - 0.2 }, { x: median, y: yPos + 0.2 }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 3,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Lower whisker (horizontal)
                                  {
                                      label: `${boxplotName} Lower Whisker`,
                                      data: [{ x: actualWhiskerMin, y: yPos }, { x: Q1, y: yPos }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Upper whisker (horizontal)
                                  {
                                      label: `${boxplotName} Upper Whisker`,
                                      data: [{ x: Q3, y: yPos }, { x: actualWhiskerMax, y: yPos }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Whisker caps (vertical)
                                  {
                                      label: `${boxplotName} Lower Cap`,
                                      data: [
                                          { x: actualWhiskerMin, y: yPos - 0.1 },
                                          { x: actualWhiskerMin, y: yPos + 0.1 }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  {
                                      label: `${boxplotName} Upper Cap`,
                                      data: [
                                          { x: actualWhiskerMax, y: yPos - 0.1 },
                                          { x: actualWhiskerMax, y: yPos + 0.1 }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  }
                              );

                              // Add outliers if any
                              if (actualOutliers.length > 0) {
                                  const outlierData = actualOutliers.map(outlierValue => ({ x: outlierValue, y: yPos }));
                                  datasets.push({
                                      label: `${boxplotName} Outliers`,
                                      data: outlierData,
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 5,
                                      showLine: false,
                                      type: 'scatter'
                                  });
                              }
                          } else {
                              // Vertical boxplot
                              datasets.push(
                                  // Median line (horizontal in vertical boxplot)
                                  {
                                      label: `${boxplotName} Median`,
                                      data: [{ x: xPos - 0.2, y: median }, { x: xPos + 0.2, y: median }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 3,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Lower whisker (vertical)
                                  {
                                      label: `${boxplotName} Lower Whisker`,
                                      data: [{ x: xPos, y: actualWhiskerMin }, { x: xPos, y: Q1 }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Upper whisker (vertical)
                                  {
                                      label: `${boxplotName} Upper Whisker`,
                                      data: [{ x: xPos, y: Q3 }, { x: xPos, y: actualWhiskerMax }],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  // Whisker caps (horizontal)
                                  {
                                      label: `${boxplotName} Lower Cap`,
                                      data: [
                                          { x: xPos - 0.1, y: actualWhiskerMin },
                                          { x: xPos + 0.1, y: actualWhiskerMin }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  },
                                  {
                                      label: `${boxplotName} Upper Cap`,
                                      data: [
                                          { x: xPos - 0.1, y: actualWhiskerMax },
                                          { x: xPos + 0.1, y: actualWhiskerMax }
                                      ],
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 0,
                                      showLine: true,
                                      type: 'line'
                                  }
                              );

                              // Add outliers if any
                              if (actualOutliers.length > 0) {
                                  const outlierData = actualOutliers.map(outlierValue => ({ x: xPos, y: outlierValue }));
                                  datasets.push({
                                      label: `${boxplotName} Outliers`,
                                      data: outlierData,
                                      backgroundColor: color,
                                      borderColor: color,
                                      borderWidth: 2,
                                      pointRadius: 5,
                                      showLine: false,
                                      type: 'scatter'
                                  });
                              }
                          }
                      }); // End of boxplots.forEach

                      // High DPI canvas resize for crisp rendering
                      const dpr = window.devicePixelRatio || 1;
                      const parentRect = canvas.parentElement.getBoundingClientRect();
                      const displayWidth = parentRect.width;
                      const displayHeight = parentRect.height;
                      canvas.width = displayWidth * dpr;
                      canvas.height = displayHeight * dpr;
                      canvas.style.width = displayWidth + 'px';
                      canvas.style.height = displayHeight + 'px';
                      // Do NOT manually scale ctx – Chart.js handles DPR internally

                      const chart = new Chart(ctx, {
                          type: 'scatter',
                          data: {
                              datasets: datasets
                          },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: isHorizontal ? {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xAxisConfig.min || (overallMin - 2),
                                      max: xAxisConfig.max || (overallMax + 2),
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor(),
                                          // Force Chart.js to respect our stepSize by providing a callback
                                          callback: function(value, index, values) {
                                              // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                              if (xAxisConfig.tickInterval) {
                                                  const step = xAxisConfig.tickInterval;
                                                  const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                                  const adjustedValue = value - min;
                                                  if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                                      // Round to mitigate floating-point artifacts
                                                      return Number(value.toFixed(6));
                                                  }
                                                  return '';
                                              }
                                              return value;
                                          }
                                      }
                                  },
                                  y: {
                                      type: 'linear',
                                      min: -(boxplots.length) * 0.5,
                                      max: (boxplots.length) * 0.5,
                                      display: boxplots.length > 1,  // Show y-axis labels for multiple boxplots
                                      title: {
                                          display: boxplots.length > 1,
                                          text: 'Groups',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          display: boxplots.length > 1,
                                          color: getTextColor(),
                                          callback: function(value, index) {
                                              const boxplotIndex = Math.round(value + (boxplots.length - 1) / 2);
                                              if (boxplotIndex >= 0 && boxplotIndex < boxplots.length) {
                                                  return boxplots[boxplotIndex].name || `Group ${boxplotIndex + 1}`;
                                              }
                                              return '';
                                          }
                                      }
                                  }
                              } : {
                                  x: {
                                      type: 'linear',
                                      min: -(boxplots.length) * 0.5,
                                      max: (boxplots.length) * 0.5,
                                      display: boxplots.length > 1,  // Show x-axis labels for multiple boxplots
                                      title: {
                                          display: boxplots.length > 1,
                                          text: 'Groups',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          display: boxplots.length > 1,
                                          color: getTextColor(),
                                          callback: function(value, index) {
                                              const boxplotIndex = Math.round(value + (boxplots.length - 1) / 2);
                                              if (boxplotIndex >= 0 && boxplotIndex < boxplots.length) {
                                                  return boxplots[boxplotIndex].name || `Group ${boxplotIndex + 1}`;
                                              }
                                              return '';
                                          }
                                      }
                                  },
                                  y: {
                                      type: 'linear',
                                      position: 'left',
                                      min: xAxisConfig.min || (overallMin - 2),
                                      max: xAxisConfig.max || (overallMax + 2),
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      },
                                      ticks: {
                                          display: !config.yAxis || !config.yAxis.hideTicks,
                                          stepSize: config.yAxis && config.yAxis.tickInterval,
                                          color: getTextColor()
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: false
                                  },
                                  tooltip: {
                                      callbacks: {
                                          title: function(context) {
                                              const dataset = context[0].dataset;
                                              return dataset.label;
                                          },
                                          label: function(context) {
                                              const dataset = context.dataset;

                                              if (dataset.label.includes('Median')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Median: ${value}`;
                                              } else if (dataset.label.includes('Outliers')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Outlier: ${value}`;
                                              } else if (dataset.label.includes('Whisker')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Whisker endpoint: ${value}`;
                                              } else if (dataset.label.includes('Cap')) {
                                                  const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                                  return `Whisker cap: ${value}`;
                                              }
                                              const value = isHorizontal ? context.parsed.x : context.parsed.y;
                                              return `Value: ${value}`;
                                          }
                                      }
                                  },
                                  datalabels: {
                                      display: (ctx) => {
                                          const cfg = (chartData.chartConfig || {});
                                          return cfg.showPointLabels === true; // off by default
                                      },
                                      color: getTextColor(),
                                      align: 'top',
                                      anchor: 'center'
                                  }
                              }
                          },
                          plugins: [{
                              id: 'boxplotBox',
                              afterDraw: function(chart) {
                                  const ctx = chart.ctx;
                                  const chartArea = chart.chartArea;
                                  ctx.save();

                                  // Draw boxes for each boxplot
                                  const boxplotSpacing = 0.8; // Space between boxplots
                                  boxplots.forEach((boxplot, index) => {
                                      const { Q1, Q3, name } = boxplot;
                                      const color = boxplotColors[index];

                                      // Set fill and stroke styles
                                      ctx.fillStyle = color + '33'; // Add transparency
                                      ctx.strokeStyle = color;
                                      ctx.lineWidth = 2;

                                      if (isHorizontal) {
                                          const xScale = chart.scales.x;
                                          const yScale = chart.scales.y;
                                          const boxHeight = 30;
                                          const yPos = (index - (boxplots.length - 1) / 2) * boxplotSpacing;
                                          const centerY = yScale.getPixelForValue(yPos);
                                          const q1X = xScale.getPixelForValue(Q1);
                                          const q3X = xScale.getPixelForValue(Q3);
                                          ctx.fillRect(q1X, centerY - boxHeight/2, q3X - q1X, boxHeight);
                                          ctx.strokeRect(q1X, centerY - boxHeight/2, q3X - q1X, boxHeight);
                                      } else {
                                          const xScale = chart.scales.x;
                                          const yScale = chart.scales.y;
                                          const boxWidth = 30;
                                          const xPos = (index - (boxplots.length - 1) / 2) * boxplotSpacing;
                                          const centerX = xScale.getPixelForValue(xPos);
                                          const q1Y = yScale.getPixelForValue(Q1);
                                          const q3Y = yScale.getPixelForValue(Q3);
                                          ctx.fillRect(centerX - boxWidth/2, q3Y, boxWidth, q1Y - q3Y);
                                          ctx.strokeRect(centerX - boxWidth/2, q3Y, boxWidth, q1Y - q3Y);
                                      }
                                  });

                                  ctx.restore();
                              }
                          }]
                      });
                      chartInstances.push(chart);
                  } else if (chartData.chartType === 'normal') {
                      // --------------------------------------------------
                      // Normal distribution curve with optional shaded region
                      // --------------------------------------------------
                      const mean = (typeof chartData.mean === 'number') ? chartData.mean : 0;
                      const sd   = (typeof chartData.sd   === 'number' && chartData.sd > 0) ? chartData.sd : 1;
                      const shade = chartData.shade || null; // {lower: number|null, upper: number|null}

                      const config        = chartData.chartConfig || {};
                      const xAxisConfig   = config.xAxis || {};
                      const yAxisConfig   = config.yAxis || {};

                      const xMin = (typeof xAxisConfig.min === 'number') ? xAxisConfig.min : mean - 3 * sd;
                      const xMax = (typeof xAxisConfig.max === 'number') ? xAxisConfig.max : mean + 3 * sd;
                      const tickInterval = (typeof xAxisConfig.tickInterval === 'number') ? xAxisConfig.tickInterval : sd;

                      const pdf = (x) => (1 / (sd * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mean) / sd, 2));

                      const numPoints = 120;
                      const curvePoints = [];
                      const shadePoints = [];

                      const peakY = pdf(mean);

                      for (let i = 0; i <= numPoints; i++) {
                          const x = xMin + (i / numPoints) * (xMax - xMin);
                          const rawY = pdf(x);
                          const y = rawY / peakY; // scale
                          curvePoints.push({ x, y });

                          if (shade) {
                              const inLower = (shade.lower == null) || (x >= shade.lower);
                              const inUpper = (shade.upper == null) || (x <= shade.upper);
                              shadePoints.push({ x, y: (inLower && inUpper) ? y : null });
                          }
                      }

                      const datasets = [{
                          label: 'Normal Curve',
                          type: 'line',
                          data: curvePoints,
                          borderColor: getTextColor(),
                          borderWidth: 2,
                          fill: false,
                          pointRadius: 0,
                          tension: 0.15
                      }];

                      if (shade) {
                          const shadeColor = isDarkMode() ? 'rgba(200,200,200,0.35)' : 'rgba(0,0,0,0.25)';
                          datasets.push({
                              label: 'Shaded Region',
                              type: 'line',
                              data: shadePoints,
                              borderColor: 'transparent',
                              backgroundColor: shadeColor,
                              fill: 'origin',
                              pointRadius: 0,
                              tension: 0.15,
                              borderWidth: 0
                          });
                      }

                      const chart = new Chart(ctx, {
                          type: 'line',
                          data: { datasets },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xMin,
                                      max: xMax,
                                      ticks: {
                                          stepSize: tickInterval,
                                          color: getTextColor()
                                      },
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'Value',
                                          color: getTextColor()
                                      },
                                      grid: { display: false }
                                  },
                                  y: {
                                      beginAtZero: true,
                                      display: false,
                                      min: 0,
                                      title: {
                                          display: !!yAxisConfig.title,
                                          text: yAxisConfig.title || '',
                                          color: getTextColor()
                                      },
                                      grid: { display: false },
                                      ticks: { display: false }
                                  }
                              },
                              plugins: { legend: { display: false }, datalabels: { display: false } }
                          }
                      });
                      chartInstances.push(chart);
                  } else if (chartData.chartType === 'chisquare') {
                      // --- New chi-square distribution rendering ---
                      const cfg = chartData.chartConfig || {};
                      const xAxisConfig = cfg.xAxis || {};
                      const yAxisConfig = cfg.yAxis || {};

                      // Accept list of degrees of freedom or single df
                      const dfList = Array.isArray(chartData.dfList) && chartData.dfList.length > 0 ?
                                      chartData.dfList :
                                      (typeof chartData.df === 'number' ? [chartData.df] : [1]);

                      // Optional labels array; default to "df = k" notation
                      const labels = Array.isArray(chartData.labels) && chartData.labels.length === dfList.length ?
                                      chartData.labels : dfList.map(df => `df = ${df}`);

                      const xMin = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : 0;
                      const xMax = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : Math.max(...dfList) * 3.5;
                      const numPoints = cfg.numPoints || 120;

                      // Lightweight Lanczos approximation for Gamma function
                      function gamma(z) {
                          const p = [
                              0.99999999999980993,
                              676.5203681218851,
                              -1259.1392167224028,
                              771.32342877765313,
                              -176.61502916214059,
                              12.507343278686905,
                              -0.13857109526572012,
                              9.9843695780195716e-6,
                              1.5056327351493116e-7
                          ];
                          const g = 7;
                          if (z < 0.5) {
                              return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
                          }
                          z -= 1;
                          let x = p[0];
                          for (let i = 1; i < p.length; i++) {
                              x += p[i] / (z + i);
                          }
                          const t = z + g + 0.5;
                          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
                      }

                      // Chi-square probability density function
                      function chiSquarePdf(x, k) {
                          if (x <= 0) return 0;
                          const coeff = 1 / (Math.pow(2, k / 2) * gamma(k / 2));
                          return coeff * Math.pow(x, k / 2 - 1) * Math.exp(-x / 2);
                      }

                      const colorPalette = generateChartColors(dfList.length);
                      const datasets = dfList.map((df, idx) => {
                          const pts = [];
                          for (let i = 0; i <= numPoints; i++) {
                              const xVal = xMin + (i / numPoints) * (xMax - xMin);
                              pts.push({ x: xVal, y: chiSquarePdf(xVal, df) });
                          }
                          const color = colorPalette[idx % colorPalette.length] || '#36A2EB';
                          return {
                              label: labels[idx],
                              type: 'line',
                              data: pts,
                              borderColor: color,
                              borderWidth: 2,
                              fill: false,
                              pointRadius: 0,
                              tension: 0.15
                          };
                      });

                      // Grid line settings (reuse existing pattern)
                      let showHorizontalGrid = true;
                      let showVerticalGrid = false;
                      if (cfg.gridLines !== undefined) {
                          if (typeof cfg.gridLines === 'boolean') {
                              showHorizontalGrid = cfg.gridLines;
                          } else if (typeof cfg.gridLines === 'object') {
                              showHorizontalGrid = cfg.gridLines.horizontal !== false;
                              showVerticalGrid = cfg.gridLines.vertical === true;
                          }
                      }

                      const chart = new Chart(ctx, {
                          type: 'line',
                          data: { datasets },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      position: 'bottom',
                                      min: xMin,
                                      max: xMax,
                                      title: {
                                          display: true,
                                          text: xAxisConfig.title || 'χ²',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          stepSize: xAxisConfig.tickInterval,
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showVerticalGrid,
                                          color: getGridColor()
                                      }
                                  },
                                  y: {
                                      beginAtZero: true,
                                      title: {
                                          display: !!yAxisConfig.title,
                                          text: yAxisConfig.title || '',
                                          color: getTextColor()
                                      },
                                      ticks: {
                                          display: yAxisConfig.hideTicks !== true,
                                          color: getTextColor()
                                      },
                                      grid: {
                                          display: showHorizontalGrid,
                                          color: getGridColor()
                                      }
                                  }
                              },
                              plugins: {
                                  legend: {
                                      display: dfList.length > 1,
                                      labels: { color: getTextColor() }
                                  },
                                  datalabels: {
                                      display: cfg.showPointLabels === true,
                                      color: getTextColor()
                                  }
                              }
                          }
                      });
                      chartInstances.push(chart);
                  } else if (chartData.chartType === 'numberline') {
                      // --------------------------------------------------
                      // Custom number line (baseline with ticks & labels)
                      // --------------------------------------------------
                      const ticksData = Array.isArray(chartData.ticks) && chartData.ticks.length > 0 ? chartData.ticks : [
                          { x: -2, label: 'a' },
                          { x: -1, label: 'b' },
                          { x:  0, label: 'c' },
                          { x:  1, label: 'd' },
                          { x:  2, label: 'e' }
                      ];

                      // Determine horizontal span (add small margin so arrow-heads don't clip)
                      const xs = ticksData.map(t => t.x);
                      const minX = Math.min(...xs) - 0.5;
                      const maxX = Math.max(...xs) + 0.5;

                      // Build baseline dataset (straight line at y = 0)
                      const baselineDS = {
                          label: 'Number Line',
                          type: 'line',
                          data: [ { x: minX, y: 0 }, { x: maxX, y: 0 } ],
                          borderColor: getTextColor(),
                          borderWidth: 2,
                          pointRadius: 0,
                          fill: false,
                          tension: 0
                      };

                      // Inline plugin to draw ticks, labels, and arrow-heads
                      const numberLinePlugin = {
                          id: 'numberLinePlugin',
                          afterDraw: (chart) => {
                              const ctx = chart.ctx;
                              const xScale = chart.scales.x;
                              const yScale = chart.scales.y;
                              const y0 = yScale.getPixelForValue(0);

                              ctx.save();
                              ctx.strokeStyle = getTextColor();
                              ctx.fillStyle   = getTextColor();
                              ctx.lineWidth   = 2;

                              // Arrow-heads
                              const arrowSize = 6;
                              const leftPx  = xScale.getPixelForValue(minX);
                              const rightPx = xScale.getPixelForValue(maxX);

                              // Left arrow
                              ctx.beginPath();
                              ctx.moveTo(leftPx + arrowSize, y0 - arrowSize);
                              ctx.lineTo(leftPx, y0);
                              ctx.lineTo(leftPx + arrowSize, y0 + arrowSize);
                              ctx.closePath();
                              ctx.fill();

                              // Right arrow
                              ctx.beginPath();
                              ctx.moveTo(rightPx - arrowSize, y0 - arrowSize);
                              ctx.lineTo(rightPx, y0);
                              ctx.lineTo(rightPx - arrowSize, y0 + arrowSize);
                              ctx.closePath();
                              ctx.fill();

                              // Ticks & labels
                              const tickHeight = 12; // increased for visibility
                              ctx.font = '14px sans-serif';
                              ctx.textAlign = 'center';
                              ticksData.forEach(tk => {
                                  const xPx = xScale.getPixelForValue(tk.x);
                                  // Tick mark
                                  if (tk.drawTick !== false) {
                                    ctx.beginPath();
                                    ctx.moveTo(xPx, y0 - tickHeight);
                                    ctx.lineTo(xPx, y0 + tickHeight);
                                    ctx.stroke();
                                  }
                                  // Top label
                                  if (tk.label || tk.topLabel) {
                                    ctx.textBaseline = 'bottom';
                                    ctx.fillText(tk.label || tk.topLabel, xPx, y0 - tickHeight - 4);
                                  }
                                  // Bottom label
                                  if (tk.bottomLabel || tk.valueLabel) {
                                    ctx.textBaseline = 'top';
                                    ctx.fillText(tk.bottomLabel || tk.valueLabel, xPx, y0 + tickHeight + 4);
                                  }
                              });
                              ctx.restore();
                          }
                      };

                      const xAxisCfg = chartData.xAxis || {};

                      const chart = new Chart(ctx, {
                          type: 'line',
                          data: { datasets: [baselineDS] },
                          options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              animation: false,
                              scales: {
                                  x: {
                                      type: 'linear',
                                      min: xAxisCfg.min !== undefined ? xAxisCfg.min : minX,
                                      max: xAxisCfg.max !== undefined ? xAxisCfg.max : maxX,
                                      ticks: {
                                          display: false
                                      },
                                      grid: { display: false },
                                      title: {
                                          display: !!xAxisCfg.title,
                                          text: xAxisCfg.title || '',
                                          color: getTextColor()
                                      }
                                  },
                                  y: {
                                      min: -1,
                                      max: 1,
                                      display: false,
                                      grid: { display: false }
                                  }
                              },
                              plugins: {
                                  legend: { display: false },
                                  datalabels: { display: false }
                              }
                          },
                          plugins: [numberLinePlugin]
                      });
                      chartInstances.push(chart);
                  }
              }, 100);

              return chartHtml;
          }
          // FIXED: Table rendering to handle both object and array formats
          function renderTable(table) {
              if (!table) return '';

              let tableHtml = '<div class="table-container"><table>';

              // Handle object format (with headers and rows properties)
              if (table.headers && table.rows) {
                  // Render headers
                  tableHtml += '<thead><tr>';
                  table.headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Render rows
                  if (table.rows && table.rows.length > 0) {
                      tableHtml += '<tbody>';
                      table.rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }
              // Handle array format (legacy)
              else if (Array.isArray(table) && table.length > 0) {
                  const headers = table[0];
                  const rows = table.slice(1);

                  // Headers
                  tableHtml += '<thead><tr>';
                  headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Rows
                  if (rows.length > 0) {
                      tableHtml += '<tbody>';
                      rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }

              tableHtml += '</table></div>';

              return tableHtml;
          }

          function renderChoices(choices, question) {
              if (!choices || !Array.isArray(choices)) return '';

              const questionId = question ? question.id : 'unknown';

              // Step 3: Check attempts from classData instead
              let attempts = 0;
              if (currentUsername && classData && classData.users[currentUsername]) {
                  attempts = classData.users[currentUsername].attempts[questionId] || 0;
              }

              let choicesHtml = '<div class="choices">';
              choices.forEach(choice => {
                  choicesHtml += `
                      <div class="choice">
                          <label style="display: flex; align-items: center; cursor: pointer;">
                              <input type="radio" name="choice-${questionId}" value="${choice.key}" 
                                     ${attempts >= 3 ? 'disabled' : ''} />
                              <span class="choice-key">${choice.key}.</span>
                              <span class="choice-value">${choice.value}</span>
                          </label>
                      </div>
                  `;
              });
              choicesHtml += '</div>';

              return choicesHtml;
          }

          function renderQuestion(question, index) {
              const questionNumber = index + 1;
              let questionHtml = `
                  <div class="quiz-container" data-question-number="${questionNumber}" data-question-id="${question.id || ''}">
                      <div class="question-header">Question ${questionNumber}</div>
                      <div class="question-id">ID: ${question.id || 'N/A'}</div>
                      <div class="question-prompt">${question.prompt || 'No prompt provided'}</div>
              `;

              // Render attachments if present
              if (question.attachments) {
                  // Render image if present
                  if (question.attachments.image) {
                      const imageAlt = question.attachments.imageAlt || 'Question image';
                      const imageCaption = question.attachments.imageCaption || '';
                      questionHtml += `
                          <div class="image-container">
                              <img src="${question.attachments.image}" alt="${imageAlt}" class="question-image">
                              ${imageCaption ? `<div class="image-caption">${imageCaption}</div>` : ''}
                          </div>
                      `;
                  }

                  // Handle multiple charts
                  if (question.attachments.charts && Array.isArray(question.attachments.charts)) {
                      if (question.attachments.charts.length > 1) {
                          questionHtml += '<div class="multiple-charts-container">';
                          question.attachments.charts.forEach((chart, idx) => {
                              questionHtml += renderChart(chart, `${question.id}-${idx}`);
                          });
                          questionHtml += '</div>';
                      } else if (question.attachments.charts.length === 1) {
                          questionHtml += renderChart(question.attachments.charts[0], question.id);
                      }
                  } else if (question.attachments.chartType) {
                      questionHtml += renderChart(question.attachments, question.id);
                  }

                  if (question.attachments.table) {
                      questionHtml += renderTable(question.attachments.table);
                  }

                  // Render choices if present (in attachments)
                  if (question.attachments.choices) {
                      questionHtml += renderChoices(question.attachments.choices, question);
                  }
              }

              // Handle choices at top level (new format) for MCQ
              if (question.type === 'multiple-choice' && question.choices) {
                  questionHtml += renderChoices(question.choices, question);
              }

              // Add FRQ textarea for free-response questions
              if (question.type === 'free-response') {
                  // Step 3: Check attempts from classData
                  let attempts = 0;
                  if (currentUsername && classData && classData.users[currentUsername]) {
                      attempts = classData.users[currentUsername].attempts[question.id] || 0;
                  }
                  questionHtml += `
                      <div class="frq-wrapper">
                          <textarea 
                              id="frq-textarea-${question.id}"
                              class="frq-textarea" 
                              placeholder="Enter your complete response here"
                              ${attempts >= 3 ? 'disabled' : ''}
                          ></textarea>
                      </div>
                  `;
              }

              // Add reason textarea and submit button zone
              // Step 3: Check attempts from classData
              let attempts = 0;
              if (currentUsername && classData && classData.users[currentUsername]) {
                  attempts = classData.users[currentUsername].attempts[question.id] || 0;
              }
              questionHtml += `
                  <div class="reason-wrapper">
                      <label for="reason-textarea-${question.id}" style="display: block; margin-bottom: 5px; font-weight: bold;">
                          Optional: Explain your reasoning (visible to peers)
                      </label>
                      <textarea 
                          id="reason-textarea-${question.id}"
                          class="reason-textarea" 
                          placeholder="Why did you choose this answer?"
                          ${attempts >= 3 ? 'disabled' : ''}
                      ></textarea>
                  </div>

                  <!-- Submit button zone with error message -->
                  <div class="question-submit-zone">
                      <span id="error-${question.id}" class="error-msg"></span>
                      <button 
                          id="submit-${question.id}"
                          class="submit-button" 
                          onclick="submitAnswer('${question.id}', '${question.type}')"
                          ${attempts >= 3 ? 'disabled' : ''}
                      >
                          ${attempts >= 3 ? 'Maximum attempts reached (3/3)' : `Submit Answer (Attempt ${attempts + 1} of 3)`}
                      </button>
                      <button 
                          id="view-${question.id}"
                          class="view-button" 
                          style="margin-left: 10px; display: none;"
                          disabled
                          onclick="toggleView('${question.id}')"
                      >
                          View Distribution
                      </button>
                      <div id="success-${question.id}" class="submission-success"></div>
                      ${attempts >= 3 ? '<div class="max-attempts-message" style="color: #ff9800; font-weight: bold;">Maximum 3 attempts reached - no further changes allowed</div>' :
  ''}
                  </div>
              `;

              
              // Add view section container
              questionHtml += `<div id="view-section-${question.id}" class="view-section"></div>`;
              questionHtml += '</div>';
              return questionHtml;
          }

          function cleanJsonText(text) {
              try {
                  // Step 1: Remove all comment lines and empty lines
                  const lines = text.split('\n');
                  const cleanedLines = lines.filter(line => {
                      const trimmed = line.trim();
                      return trimmed && !trimmed.startsWith('//');
                  });

                  // Step 2: Join and attempt to parse
                  let cleanedText = cleanedLines.join('\n');

                  // Step 3: Remove trailing commas before closing brackets/braces
                  cleanedText = cleanedText.replace(/,\s*}/g, '}');
                  cleanedText = cleanedText.replace(/,\s*]/g, ']');

                  return cleanedText;
              } catch (e) {
                  // If cleaning fails, return original text
                  return text;
              }
          }

          function renderQuiz(data) {
              try {
                  // Store data for dark mode re-rendering
                  window.lastLoadedData = data;

                  // Clear existing charts first
                  chartInstances.forEach(chart => chart.destroy());
                  chartInstances = [];

                  let questions = [];

                  // Handle different JSON structures
                  if (Array.isArray(data)) {
                      questions = data;
                  } else if (data.questions && Array.isArray(data.questions)) {
                      questions = data.questions;
                  } else if (typeof data === 'object') {
                      // Check if it's a single question object
                      if (data.id && data.prompt) {
                          questions = [data];
                      } else {
                          // Try to extract questions from object properties
                          questions = Object.values(data).filter(item =>
                              typeof item === 'object' && item.id && item.prompt
                          );
                      }
                  }

                  if (questions.length === 0) {
                      showMessage('No valid questions found in the JSON data. Please check the format.');
                      return;
                  }

                  showStats(questions);

                  const questionsContainer = document.getElementById('questionsContainer');

                  // Add app controls at the top
                  let questionsHtml = `
                      <div class="app-controls">
                          <div class="user-info">
                              <input type="text" id="username" placeholder="Enter username" />
                          </div>
                          <div class="filter-controls">
                              <!-- Filters will be added in future steps -->
                          </div>
                          <button id="modeToggle" onclick="toggleMode()">Switch to View Mode</button>
                          <button id="export-btn" class="load-button" onclick="exportPersonal()">Export My Data</button>
                          <input type="file" id="import-input" accept=".json" style="display:none;" onchange="importClassData(event)">
                          <button class="load-button" onclick="document.getElementById('import-input').click()">Import Class Data</button>
                          <input type="file" id="merge-input" multiple accept=".json" style="display:none;" onchange="mergeImports(event)">
                          <button class="load-button" onclick="document.getElementById('merge-input').click()">Merge Imports</button>
                          <div id="sync-status"></div>
                      </div>
                  `;

                  questions.forEach((question, index) => {
                      questionsHtml += renderQuestion(question, index);
                  });

                  questionsContainer.innerHTML = questionsHtml;

                  // Trigger MathJax rendering for LaTeX content
                  if (window.MathJax) {
                      MathJax.typesetPromise().catch((e) => console.log('MathJax error:', e));
                  }

                  // Initialize context finder after questions are rendered
                  initContextFinder();

                  // Step 3: Load progress after rendering
                  loadProgress();

                  showMessage(`Successfully loaded ${questions.length} question(s)!`, 'success');
              } catch (error) {
                  showMessage('Error rendering quiz: ' + error.message, 'error');
                  console.error('Render error:', error);
              }
          }

          function updateContextFinder() {
              const contextDiv = document.getElementById('contextFinder');
              if (!contextDiv) return;

              const questionElements = document.querySelectorAll('.quiz-container');
              let currentEl = null;
              let minDistance = Number.POSITIVE_INFINITY;

              questionElements.forEach(el => {
                  const rect = el.getBoundingClientRect();
                  const elementTop = rect.top;
                  const elementBottom = rect.bottom;
                  const viewportHeight = window.innerHeight;

                  // Check if element is in viewport
                  if (elementTop < viewportHeight && elementBottom > 0) {
                      // Calculate distance from top of viewport
                      const distance = Math.abs(elementTop);
                      if (distance < minDistance) {
                          minDistance = distance;
                          currentEl = el;
                      }
                  }
              });

              if (currentEl) {
                  const questionNumber = currentEl.getAttribute('data-question-number');
                  const questionId = currentEl.getAttribute('data-question-id');
                  contextDiv.innerHTML = `📍 Question ${questionNumber}<br><small>${questionId || 'No ID'}</small>`;
              }
          }

          function initContextFinder() {
              const contextDiv = document.getElementById('contextFinder');
              if (!contextDiv) return;

              // Disconnect previous observer if it exists (not used now but for cleanup)
              if (contextObserver) {
                  contextObserver.disconnect();
              }

              // Attach scroll handler once
              if (!contextScrollHandlerAttached) {
                  window.addEventListener('scroll', () => requestAnimationFrame(updateContextFinder));
                  window.addEventListener('resize', () => requestAnimationFrame(updateContextFinder));
                  contextScrollHandlerAttached = true;
              }

              // Initial content and display
              const questionElements = document.querySelectorAll('.quiz-container');
              if (questionElements.length > 0) {
                  const firstQuestion = questionElements[0];
                  const questionNumber = firstQuestion.getAttribute('data-question-number');
                  const questionId = firstQuestion.getAttribute('data-question-id');
                  contextDiv.innerHTML = `📍 Question ${questionNumber}<br><small>${questionId || 'No ID'}</small>`;
              }

              contextDiv.style.display = 'block';
              updateContextFinder();
          }

          // Mode toggle functionality
          function toggleMode() {
              const currentMode = document.body.getAttribute('data-mode') || 'answer';
              const newMode = currentMode === 'answer' ? 'view' : 'answer';
              document.body.setAttribute('data-mode', newMode);

              const button = document.getElementById('modeToggle');
              if (button) {
                  button.textContent = newMode === 'answer' ? 'Switch to View Mode' : 'Switch to Answer Mode';
              }

              buttonTones.click();
          }

          // Initialize mode on load
          document.addEventListener('DOMContentLoaded', () => {
              document.body.setAttribute('data-mode', 'answer');

              // Check for username in localStorage
              const savedUsername = localStorage.getItem('consensusUsername');
              if (savedUsername) {
                  const usernameInput = document.getElementById('username');
                  if (usernameInput) {
                      usernameInput.value = savedUsername;
                  }
              }

              // Save username on change
              document.addEventListener('input', (e) => {
                  if (e.target.id === 'username') {
                      localStorage.setItem('consensusUsername', e.target.value);
                  }
              });
          });

          // Load sample data on page load
          window.onload = function() {
              initTheme();
              promptUsername();
              showMessage('🚀 Consensus Quiz Renderer Ready! Load your curriculum.json or use the debug button to start.', 'success');
          };

          // Generic click sound for ANY interactive element
          document.addEventListener('click', (e) => {
              const choiceEl = e.target.closest('.choice');
              if (choiceEl) {
                  buttonTones.click();
              }
          });
      </script>
  </body>
  </html>