CHUNK_3_START
function loadFromFile() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    
    if (!file) {
        showMessage('Please select a file first', 'error');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const jsonText = e.target.result;
            const cleanedJson = cleanJsonText(jsonText);
            const data = JSON.parse(cleanedJson);
            renderQuiz(data);
            showMessage('Quiz loaded successfully from file!', 'success');
            buttonTones.load();
        } catch (error) {
            showMessage('Error parsing JSON: ' + error.message, 'error');
        }
    };
    reader.readAsText(file);
}

function loadFromTextarea() {
    const jsonInput = document.getElementById('jsonInput').value.trim();
    
    if (!jsonInput) {
        showMessage('Please enter JSON data in the textarea', 'error');
        return;
    }
    
    try {
        const cleanedJson = cleanJsonText(jsonInput);
        const data = JSON.parse(cleanedJson);
        renderQuiz(data);
        showMessage('Quiz loaded successfully from textarea!', 'success');
        buttonTones.load();
    } catch (error) {
        showMessage('Error parsing JSON: ' + error.message, 'error');
    }
}

function loadDebugData() {
    const debugData = [
        {
            "id": "DEBUG-MC-01",
            "type": "multiple-choice",
            "prompt": "A researcher collects data on \\(n = 50\\) students. What is the probability that the sample mean \\(\\bar{x}\\) falls within one standard error of the population mean \\(\\mu\\)?",
            "choices": [
                {"key": "A", "value": "Approximately 68%"},
                {"key": "B", "value": "Approximately 95%"},
                {"key": "C", "value": "Approximately 99.7%"},
                {"key": "D", "value": "Cannot be determined"}
            ],
            "attachments": {
                "chartType": "histogram",
                "data": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 9],
                "title": "Sample Distribution",
                "xLabel": "Value",
                "yLabel": "Frequency",
                "bins": 9
            }
        },
        {
            "id": "DEBUG-FR-01",
            "type": "free-response",
            "prompt": "A factory produces widgets with a mean weight of \\(\\mu = 100\\) grams and standard deviation \\(\\sigma = 5\\) grams. A quality control inspector randomly selects 25 widgets.",
            "attachments": {
                "table": {
                    "headers": ["Sample", "Mean (g)", "Std Dev (g)", "Min (g)", "Max (g)"],
                    "rows": [
                        ["1", "99.2", "4.8", "89.5", "108.3"],
                        ["2", "101.5", "5.2", "91.2", "111.8"],
                        ["3", "100.3", "4.9", "90.1", "109.5"],
                        ["4", "98.7", "5.5", "87.3", "110.2"],
                        ["5", "100.8", "4.7", "92.4", "108.9"]
                    ]
                }
            }
        },
        {
            "id": "DEBUG-CHART-01",
            "type": "multiple-choice",
            "prompt": "Based on the scatter plot below, what type of relationship exists between the variables?",
            "choices": [
                {"key": "A", "value": "Strong positive linear"},
                {"key": "B", "value": "Strong negative linear"},
                {"key": "C", "value": "No relationship"},
                {"key": "D", "value": "Non-linear relationship"}
            ],
            "attachments": {
                "chartType": "scatter",
                "xData": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                "yData": [2.1, 3.9, 6.1, 7.8, 10.2, 11.9, 14.1, 15.8, 18.2, 19.9],
                "title": "Relationship Between X and Y",
                "xLabel": "X Variable",
                "yLabel": "Y Variable",
                "showTrendline": true
            }
        }
    ];
    
    document.getElementById('jsonInput').value = JSON.stringify(debugData, null, 2);
    renderQuiz(debugData);
    showMessage('Debug data loaded with histogram, table, and scatter plot examples!', 'success');
    buttonTones.load();
}

// COMPLETE CHART RENDERING FROM ORIGINAL quiz_renderer.html
function renderChart(chartData, questionId) {
    const chartId = `chart-${questionId}`;
    const config = chartData.chartConfig || {};
    
    // Use the chart's title if available, otherwise use the chart type
    const chartTitle = chartData.title ? 
        chartData.title : 
        (config.description ? 
            `ðŸ“Š ${chartData.chartType.toUpperCase()} CHART` : 
            `ðŸ“Š ${chartData.chartType.toUpperCase()} CHART`);
    
    // Allow a chart to request full horizontal space when rendered inside a "multiple-charts-container"
    const containerStyle = chartData.fullWidth ? 'style="flex:0 0 100%; max-width:100%; width:100%;"' : '';
    
    let chartHtml = `
        <div class="chart-container" ${containerStyle}>
            <div class="chart-title">${chartTitle}</div>
            ${config.description ? `<div style="font-size: 0.9em; color: #666; text-align: center; margin-bottom: 10px; font-style: italic;">${config.description}</div>` : ''}
            <div class="chart-canvas">
                <canvas id="${chartId}"></canvas>
            </div>
        </div>
    `;

    // Return HTML first, then we'll create the chart after the DOM is updated
    setTimeout(() => {
        const canvas = document.getElementById(chartId);
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        
        if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
            // Ensure every segment in a stacked / segmented bar gets its own visually distinct color
            // 1. Compute one shared palette sized to the total number of series.
            // 2. Pick the palette entry matching the series index (wrap-around safety for very large N).
            const colorPalette = generateChartColors(chartData.series.length);

            const datasets = chartData.series.map((series, index) => {
                const color = colorPalette[index % colorPalette.length] || '#36A2EB';
                return {
                    label: series.name,
                    data: series.values,
                    backgroundColor: color,
                    borderColor: color,
                    borderWidth: 1
                };
            });

            // Use chartConfig if available, otherwise use defaults
            const yAxisConfig = config.yAxis || {};
            const xAxisConfig = config.xAxis || {};
            
            // Handle grid lines - support both old and new formats
            let showHorizontalGrid = true;
            let showVerticalGrid = false;
            
            if (config.gridLines !== undefined) {
                if (typeof config.gridLines === 'boolean') {
                    // Old format: gridLines: true/false
                    showHorizontalGrid = config.gridLines;
                    showVerticalGrid = false;
                } else if (typeof config.gridLines === 'object') {
                    // New format: gridLines: {horizontal: true, vertical: false}
                    showHorizontalGrid = config.gridLines.horizontal !== false;
                    showVerticalGrid = config.gridLines.vertical === true;
                }
            }
            
            // Configure bar spacing - gaps for bar charts, no gaps for histograms
            const isHistogram = chartData.chartType === 'histogram';
            const categoryPercentage = isHistogram ? 1.0 : 0.8;
            const barPercentage = isHistogram ? 1.0 : 0.9;

            // NEW: Detect orientation for bar charts (default to vertical)
            const orientation = config.orientation || 'vertical';
            const isHorizontalBar = orientation === 'horizontal';

            // NEW: Detect if bars should be stacked (applies only to bar charts)
            const isStacked = config.stacked === true || config.stacked === 'true';

            // Handle labels based on orientation - support both xLabels and yLabels
            let displayLabels = isHorizontalBar ? (chartData.yLabels || chartData.xLabels) : (chartData.xLabels || chartData.yLabels);

            // Preserve existing labelType overrides
            if (xAxisConfig.labelType === 'upperBound' && xAxisConfig.labels) {
                displayLabels = xAxisConfig.labels;
            } else if (xAxisConfig.labelType === 'range' && chartData.xLabels) {
                displayLabels = chartData.xLabels;
            } else if (xAxisConfig.labelType === 'lowerBound') {
                displayLabels = xAxisConfig.labels || chartData.xLabels;
            }

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: displayLabels,
                    datasets: datasets
                },
                options: {
                    indexAxis: isHorizontalBar ? 'y' : 'x',
                    responsive: true,
                    maintainAspectRatio: false,
                    categoryPercentage: categoryPercentage,
                    barPercentage: barPercentage,
                    scales: isHorizontalBar ? {
                        x: {
                            beginAtZero: xAxisConfig.min !== undefined ? (xAxisConfig.min === 0) : true,
                            min: xAxisConfig.min,
                            max: xAxisConfig.max,
                            title: {
                                display: true,
                                text: xAxisConfig.title || 'Value',
                                color: getTextColor()
                            },
                            grid: {
                                display: showVerticalGrid,
                                color: getGridColor()
                            },
                            stacked: isStacked,
                            ticks: {
                                stepSize: xAxisConfig.tickInterval,
                                maxTicksLimit: xAxisConfig.tickInterval ? undefined : 10,
                                precision: 2,
                                color: getTextColor(),
                                // Force Chart.js to respect our stepSize by providing a callback
                                callback: function(value, index, values) {
                                    // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                    if (xAxisConfig.tickInterval) {
                                        const step = xAxisConfig.tickInterval;
                                        const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                        const adjustedValue = value - min;
                                        if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                            // Round to mitigate floating-point artifacts
                                            return Number(value.toFixed(6));
                                        }
                                        return '';
                                    }
                                    return value;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yAxisConfig.title || 'Category',
                                color: getTextColor()
                            },
                            grid: {
                                display: showHorizontalGrid,
                                color: getGridColor()
                            },
                            ticks: {
                                color: getTextColor()
                            },
                            offset: true
                        }
                    } : {
                        y: {
                            beginAtZero: yAxisConfig.min !== undefined ? (yAxisConfig.min === 0) : true,
                            min: yAxisConfig.min,
                            max: yAxisConfig.max,
                            title: {
                                display: true,
                                text: yAxisConfig.title || 'Value',
                                color: getTextColor()
                            },
                            grid: {
                                display: showHorizontalGrid,
                                color: getGridColor(),
                                lineWidth: 1,
                                drawBorder: true,
                                drawOnChartArea: true,
                                drawTicks: !yAxisConfig.hideTicks
                            },
                            stacked: isStacked,
                            ticks: {
                                stepSize: yAxisConfig.tickInterval,
                                maxTicksLimit: yAxisConfig.tickInterval ? undefined : 10,
                                precision: 2,
                                color: getTextColor(),
                                display: !yAxisConfig.hideTicks,
                                // Force Chart.js to respect our stepSize by providing a callback
                                callback: function(value, index, values) {
                                    if (yAxisConfig.hideTicks) return '';
                                    // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                    if (yAxisConfig.tickInterval) {
                                        const step = yAxisConfig.tickInterval;
                                        const min = yAxisConfig.min !== undefined ? yAxisConfig.min : 0;
                                        const adjustedValue = value - min;
                                        if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                            // Round to mitigate floating-point artifacts
                                            return Number(value.toFixed(6));
                                        }
                                        return '';
                                    }
                                    return value;
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: xAxisConfig.title || 'Category',
                                color: getTextColor()
                            },
                            grid: {
                                display: showVerticalGrid,
                                color: getGridColor()
                            },
                            stacked: isStacked,
                            ticks: {
                                color: getTextColor()
                            },
                            offset: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: datasets.length > 1,
                            labels: {
                                color: getTextColor()
                            }
                        },
                        // Enable data labels for bar/histogram charts when requested via chartConfig.showPointLabels
                        datalabels: {
                            display: config.showPointLabels === true,
                            color: getTextColor(),
                            anchor: isHorizontalBar ? 'center' : 'end',
                            align: isHorizontalBar ? 'right' : 'top',
                            formatter: (value) => value
                        }
                    }
                }
            });
            chartInstances.push(chart);
        
        } else if (chartData.chartType === 'pie') {
            const seriesData = chartData.series[0].values;
            const labels = seriesData.map(item => item.name);
            const values = seriesData.map(item => item.value);
            
            const chart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: generateChartColors(values.length),
                        borderWidth: 2,
                        borderColor: isDarkMode() ? '#2d2d2d' : '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 20,
                                usePointStyle: true,
                                color: getTextColor()
                            }
                        },
                        // Optional data labels for pie charts (percentages) when chartConfig.showPointLabels is true
                        datalabels: {
                            display: (config.showPointLabels === true),
                            color: getTextColor(),
                            formatter: function(value, context) {
                                const total = values.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return percentage + '%';
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = values.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.parsed} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
            chartInstances.push(chart);
        
        } else if (chartData.chartType === 'scatter') {
            const config = chartData.chartConfig || {};
            const xAxisConfig = config.xAxis || {};
            const yAxisConfig = config.yAxis || {};
            
            // Handle grid lines - support both old and new formats
            let showHorizontalGrid = true;
            let showVerticalGrid = true; // Scatter plots often show both grids
            
            if (config.gridLines !== undefined) {
                if (typeof config.gridLines === 'boolean') {
                    // Old format: gridLines: true/false
                    showHorizontalGrid = config.gridLines;
                    showVerticalGrid = config.gridLines;
                } else if (typeof config.gridLines === 'object') {
                    // New format: gridLines: {horizontal: true, vertical: false}
                    showHorizontalGrid = config.gridLines.horizontal === true;
                    showVerticalGrid = config.gridLines.vertical === true;
                }
            }
            
            // Build primary dataset (scatter points)
            const datasets = [{
                label: 'Data Points',
                data: chartData.points,
                backgroundColor: getScatterPointColor(),
                borderColor: getScatterPointColor(),
                pointRadius: 4,
                pointHoverRadius: 6
            }];

            // Determine if we should render point labels
            const hasPointLabels = (chartData.points || []).some(pt => pt.label !== undefined);

            // --------------------------------------------------
            // Optional regression line (least-squares)            <-- ADD
            // --------------------------------------------------
            if (config.regressionLine) {
                const pts = chartData.points || [];
                if (Array.isArray(pts) && pts.length >= 2) {
                    // Compute least-squares slope and intercept
                    let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
                    pts.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        sumXY += p.x * p.y;
                        sumXX += p.x * p.x;
                    });
                    const n = pts.length;
                    const denominator = n * sumXX - sumX * sumX;
                    if (denominator !== 0) {
                        const slope = (n * sumXY - sumX * sumY) / denominator;
                        const intercept = (sumY - slope * sumX) / n;

                        // Determine the horizontal span for the line
                        let minX = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : undefined;
                        let maxX = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : undefined;
                        if (minX === undefined || maxX === undefined) {
                            const xs = pts.map(p => p.x);
                            if (minX === undefined) minX = Math.min(...xs);
                            if (maxX === undefined) maxX = Math.max(...xs);
                        }

                        // Style overrides (optional)
                        const regColor = config.regressionLineColor || getTextColor();
                        const regDash  = config.regressionLineDash  || [];

                        datasets.push({
                            label: 'Regression Line',
                            type: 'line',
                            data: [
                                { x: minX, y: slope * minX + intercept },
                                { x: maxX, y: slope * maxX + intercept }
                            ],
                            borderColor: regColor,
                            borderDash: regDash,
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            tension: 0,
                            order: 0
                        });
                    }
                }
            }

            // --------------------------------------------------
            // Optional reference line at y = 0 (useful for residual plots)
            // --------------------------------------------------
            if (config.referenceLineAtZero) {
                // Determine horizontal span of the scatter data (fallback to axis min/max)
                let minX = typeof xAxisConfig.min === 'number' ? xAxisConfig.min : undefined;
                let maxX = typeof xAxisConfig.max === 'number' ? xAxisConfig.max : undefined;
                if (minX === undefined || maxX === undefined) {
                    const xs = chartData.points.map(p => p.x);
                    if (minX === undefined) minX = Math.min(...xs);
                    if (maxX === undefined) maxX = Math.max(...xs);
                }

                datasets.push({
                    label: 'Reference Line y = 0',
                    type: 'line',
                    data: [
                        { x: minX, y: 0 },
                        { x: maxX, y: 0 }
                    ],
                    borderColor: '#CC0000',
                    borderDash: [6, 4],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    order: 0
                });
            }

            const chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: xAxisConfig.min,
                            max: xAxisConfig.max,
                            title: {
                                display: true,
                                text: xAxisConfig.title || 'X Variable',
                                color: getTextColor()
                            },
                            grid: {
                                display: showVerticalGrid,
                                color: getGridColor()
                            },
                            ticks: {
                                stepSize: xAxisConfig.tickInterval,
                                color: getTextColor(),
                                // Force Chart.js to respect our stepSize by providing a callback
                                callback: function(value, index, values) {
                                    // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                    if (xAxisConfig.tickInterval) {
                                        const step = xAxisConfig.tickInterval;
                                        const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                        const adjustedValue = value - min;
                                        if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                            // Round to mitigate floating-point artifacts
                                            return Number(value.toFixed(6));
                                        }
                                        return '';
                                    }
                                    return value;
                                }
                            }
                        },
                        y: {
                            min: yAxisConfig.min,
                            max: yAxisConfig.max,
                            title: {
                                display: true,
                                text: yAxisConfig.title || 'Y Variable',
                                color: getTextColor()
                            },
                            grid: {
                                display: showHorizontalGrid,
                                color: getGridColor()
                            },
                            ticks: {
                                stepSize: yAxisConfig.tickInterval,
                                color: getTextColor(),
                                // Force Chart.js to respect our stepSize by providing a callback
                                callback: function(value, index, values) {
                                    // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                    if (yAxisConfig.tickInterval) {
                                        const step = yAxisConfig.tickInterval;
                                        const min = yAxisConfig.min !== undefined ? yAxisConfig.min : 0;
                                        const adjustedValue = value - min;
                                        if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                            // Round to mitigate floating-point artifacts
                                            return Number(value.toFixed(6));
                                        }
                                        return '';
                                    }
                                    return value;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: (ctx) => {
                                const d = ctx.dataset.data[ctx.dataIndex];
                                // Show label if point has 'label' or global chartConfig requests labels
                                return (d && d.label !== undefined) || config.showPointLabels === true;
                            },
                            align: 'top',
                            anchor: 'center',
                            color: getTextColor(),
                            formatter: (value) => {
                                // If value has explicit label use that, otherwise display y
                                if (value.label !== undefined) return value.label;
                                if (config.showPointLabels === true) {
                                    return `(${value.x}, ${value.y})`;
                                }
                                return '';
                            },
                            font: {
                                size: 12
                            }
                        }
                    }
                }
            });
            chartInstances.push(chart);

            // Add point label plugin AFTER chart creation to ensure meta is available
            if (false && (hasPointLabels || config.showPointLabels)) {
                // Create inline plugin specific to this chart instance
                const labelPlugin = {
                    id: 'scatterPointLabels',
                    afterDatasetsDraw: (c) => {
                        if (c !== chart) return; // Only draw for this chart instance
                        const ctx = c.ctx;
                        ctx.save();
                        c.data.datasets.forEach((ds, dsi) => {
                            // Only annotate the point dataset (assumed first) or explicitly marked datasets
                            if (dsi !== 0) return;
                            const meta = c.getDatasetMeta(dsi);
                            meta.data.forEach((elem, idx) => {
                                const pointData = ds.data[idx];
                                const lbl = pointData && pointData.label;
                                if (lbl === undefined) return;
                                const {x, y} = elem.getCenterPoint();
                                ctx.fillStyle = getTextColor();
                                ctx.font = '12px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';
                                ctx.fillText(lbl, x, y - 6);
                            });
                        });
                        ctx.restore();
                    }
                };
                chart.options.plugins = chart.options.plugins || [];
                chart.options.plugins.push(labelPlugin);
                chart.update();
            }
        
        } else if (chartData.chartType === 'dotplot') {
            const config = chartData.chartConfig || {};
            const xAxisConfig = config.xAxis || {};
            
            // Handle grid lines - dotplots typically have no grid lines
            let showHorizontalGrid = false;
            let showVerticalGrid = false;
            
            if (config.gridLines !== undefined) {
                if (typeof config.gridLines === 'boolean') {
                    showHorizontalGrid = config.gridLines;
                    showVerticalGrid = config.gridLines;
                } else if (typeof config.gridLines === 'object') {
                    showHorizontalGrid = config.gridLines.horizontal === true;
                    showVerticalGrid = config.gridLines.vertical === true;
                }
            }
            
            // Convert raw values to frequency data for dotplot
            const valueFrequency = {};
            chartData.values.forEach(value => {
                valueFrequency[value] = (valueFrequency[value] || 0) + 1;
            });
            
            // Create stacked dots data
            const dotplotData = [];
            for (const [value, frequency] of Object.entries(valueFrequency)) {
                for (let i = 1; i <= frequency; i++) {
                    dotplotData.push({
                        x: parseFloat(value),
                        y: i
                    });
                }
            }
            
            // Find max frequency for y-axis
            const maxFrequency = Math.max(...Object.values(valueFrequency));
            
            // Allow caller to set dot radius (default 4)
            const dotRadius = (config.dotRadius !== undefined ? config.dotRadius : 4);
            
            const chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Data Points',
                        data: dotplotData,
                        backgroundColor: getScatterPointColor(),
                        borderColor: getScatterPointColor(),
                        pointRadius: dotRadius,
                        pointHoverRadius: dotRadius + 2,
                        showLine: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: xAxisConfig.min,
                            max: xAxisConfig.max,
                            title: {
                                display: true,
                                text: xAxisConfig.title || 'Value',
                                color: getTextColor()
                            },
                            grid: {
                                display: showVerticalGrid,
                                color: getGridColor()
                            },
                            ticks: {
                                stepSize: xAxisConfig.tickInterval,
                                color: getTextColor(),
                                // Force Chart.js to respect our stepSize by providing a callback
                                callback: function(value, index, values) {
                                    // If we have a specific tickInterval, ensure we only show ticks at those intervals
                                    if (xAxisConfig.tickInterval) {
                                        const step = xAxisConfig.tickInterval;
                                        const min = xAxisConfig.min !== undefined ? xAxisConfig.min : 0;
                                        const adjustedValue = value - min;
                                        if (Math.abs(adjustedValue % step) < 0.000001 || Math.abs(adjustedValue % step - step) < 0.000001) {
                                            // Round to mitigate floating-point artifacts
                                            return Number(value.toFixed(6));
                                        }
                                        return '';
                                    }
                                    return value;
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            min: 0,
                            max: maxFrequency + 1,
                            title: {
                                display: false  // Dotplots don't typically show y-axis labels
                            },
                            grid: {
                                display: showHorizontalGrid,
                                color: getGridColor()
                            },
                            ticks: {
                                display: false,  // Hide y-axis tick labels
                                stepSize: 1
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: () => config.showPointLabels === true,
                            align: 'top',
                            anchor: 'center',
                            color: getTextColor(),
                            formatter: (value) => value.y,
                            font: { size: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `Value: ${context[0].parsed.x}`;
                                },
                                label: function(context) {
                                    return `Count: ${valueFrequency[context.parsed.x]}`;
                                }
                            }
                        }
                    }
                }
            });
             chartInstances.push(chart);

            // Adjust chart height so stacked dots appear closer (rough heuristic)
            const minHeight = 120;
            const desiredHeight = Math.max(minHeight, (dotRadius * 2 + 4) * (maxFrequency + 1));
            canvas.parentElement.style.height = desiredHeight + 'px';
         

        } 
            CHUNK_3_END