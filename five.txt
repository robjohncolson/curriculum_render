CHUNK_5_START
// FIXED: Table rendering to handle both object and array formats
function renderTable(table) {
    if (!table) return '';
    
    let tableHtml = '<div class="table-container"><table>';
    
    // Handle object format (with headers and rows properties)
    if (table.headers && table.rows) {
        // Render headers
        tableHtml += '<thead><tr>';
        table.headers.forEach(header => {
            tableHtml += `<th>${header}</th>`;
        });
        tableHtml += '</tr></thead>';
        
        // Render rows
        if (table.rows && table.rows.length > 0) {
            tableHtml += '<tbody>';
            table.rows.forEach(row => {
                tableHtml += '<tr>';
                row.forEach(cell => {
                    tableHtml += `<td>${cell}</td>`;
                });
                tableHtml += '</tr>';
            });
            tableHtml += '</tbody>';
        }
    } 
    // Handle array format (legacy)
    else if (Array.isArray(table) && table.length > 0) {
        const headers = table[0];
        const rows = table.slice(1);
        
        // Headers
        tableHtml += '<thead><tr>';
        headers.forEach(header => {
            tableHtml += `<th>${header}</th>`;
        });
        tableHtml += '</tr></thead>';
        
        // Rows
        if (rows.length > 0) {
            tableHtml += '<tbody>';
            rows.forEach(row => {
                tableHtml += '<tr>';
                row.forEach(cell => {
                    tableHtml += `<td>${cell}</td>`;
                });
                tableHtml += '</tr>';
            });
            tableHtml += '</tbody>';
        }
    }
    
    tableHtml += '</table></div>';
    
    return tableHtml;
}

function renderChoices(choices, question) {
    if (!choices || !Array.isArray(choices)) return '';
    
    const questionId = question ? question.id : 'unknown';
    
    // Step 3: Check attempts from classData instead
    let attempts = 0;
    if (currentUsername && classData && classData.users[currentUsername]) {
        attempts = classData.users[currentUsername].attempts[questionId] || 0;
    }
    
    let choicesHtml = '<div class="choices">';
    choices.forEach(choice => {
        choicesHtml += `
            <div class="choice">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="choice-${questionId}" value="${choice.key}" 
                           ${attempts >= 3 ? 'disabled' : ''} />
                    <span class="choice-key">${choice.key}.</span>
                    <span class="choice-value">${choice.value}</span>
                </label>
            </div>
        `;
    });
    choicesHtml += '</div>';
    
    return choicesHtml;
}

function renderQuestion(question, index) {
    const questionNumber = index + 1;
    let questionHtml = `
        <div class="quiz-container" data-question-number="${questionNumber}" data-question-id="${question.id || ''}">
            <div class="question-header">Question ${questionNumber}</div>
            <div class="question-id">ID: ${question.id || 'N/A'}</div>
            <div class="question-prompt">${question.prompt || 'No prompt provided'}</div>
    `;
    
    // Render attachments if present
    if (question.attachments) {
        // Render image if present
        if (question.attachments.image) {
            const imageAlt = question.attachments.imageAlt || 'Question image';
            const imageCaption = question.attachments.imageCaption || '';
            questionHtml += `
                <div class="image-container">
                    <img src="${question.attachments.image}" alt="${imageAlt}" class="question-image">
                    ${imageCaption ? `<div class="image-caption">${imageCaption}</div>` : ''}
                </div>
            `;
        }
        
        // Handle multiple charts
        if (question.attachments.charts && Array.isArray(question.attachments.charts)) {
            if (question.attachments.charts.length > 1) {
                questionHtml += '<div class="multiple-charts-container">';
                question.attachments.charts.forEach((chart, idx) => {
                    questionHtml += renderChart(chart, `${question.id}-${idx}`);
                });
                questionHtml += '</div>';
            } else if (question.attachments.charts.length === 1) {
                questionHtml += renderChart(question.attachments.charts[0], question.id);
            }
        } else if (question.attachments.chartType) {
            questionHtml += renderChart(question.attachments, question.id);
        }
        
        if (question.attachments.table) {
            questionHtml += renderTable(question.attachments.table);
        }
        
        // Render choices if present (in attachments)
        if (question.attachments.choices) {
            questionHtml += renderChoices(question.attachments.choices, question);
        }
    }

    // Handle choices at top level (new format) for MCQ
    if (question.type === 'multiple-choice' && question.choices) {
        questionHtml += renderChoices(question.choices, question);
    }
    
    // Add FRQ textarea for free-response questions
    if (question.type === 'free-response') {
        // Step 3: Check attempts from classData
        let attempts = 0;
        if (currentUsername && classData && classData.users[currentUsername]) {
            attempts = classData.users[currentUsername].attempts[question.id] || 0;
        }
        questionHtml += `
            <div class="frq-wrapper">
                <textarea 
                    id="frq-textarea-${question.id}"
                    class="frq-textarea" 
                    placeholder="Enter your complete response here"
                    ${attempts >= 3 ? 'disabled' : ''}
                ></textarea>
            </div>
        `;
    }

    // Add reason textarea and submit button zone
    // Step 3: Check attempts from classData
    let attempts = 0;
    if (currentUsername && classData && classData.users[currentUsername]) {
        attempts = classData.users[currentUsername].attempts[question.id] || 0;
    }
    questionHtml += `
        <div class="reason-wrapper">
            <label for="reason-textarea-${question.id}" style="display: block; margin-bottom: 5px; font-weight: bold;">
                Optional: Explain your reasoning (visible to peers)
            </label>
            <textarea 
                id="reason-textarea-${question.id}"
                class="reason-textarea" 
                placeholder="Why did you choose this answer?"
                ${attempts >= 3 ? 'disabled' : ''}
            ></textarea>
        </div>
        
        <!-- Submit button zone with error message -->
        <div class="question-submit-zone">
            <span id="error-${question.id}" class="error-msg"></span>
            <button 
                id="submit-${question.id}"
                class="submit-button" 
                onclick="submitAnswer('${question.id}', '${question.type}')"
                ${attempts >= 3 ? 'disabled' : ''}
            >
                ${attempts >= 3 ? 'Maximum attempts reached (3/3)' : `Submit Answer (Attempt ${attempts + 1} of 3)`}
            </button>
            <button 
                id="view-${question.id}"
                class="view-button" 
                style="margin-left: 10px; display: none;"
                disabled
            >
                View Answers
            </button>
            <div id="success-${question.id}" class="submission-success"></div>
            ${attempts >= 3 ? '<div class="max-attempts-message" style="color: #ff9800; font-weight: bold;">Maximum 3 attempts reached - no further changes allowed</div>' : ''}
        </div>
    `;

    questionHtml += '</div>';
    return questionHtml;
}

function cleanJsonText(text) {
    try {
        // Step 1: Remove all comment lines and empty lines
        const lines = text.split('\n');
        const cleanedLines = lines.filter(line => {
            const trimmed = line.trim();
            return trimmed && !trimmed.startsWith('//');
        });
        
        // Step 2: Join and attempt to parse
        let cleanedText = cleanedLines.join('\n');
        
        // Step 3: Remove trailing commas before closing brackets/braces
        cleanedText = cleanedText.replace(/,\s*}/g, '}');
        cleanedText = cleanedText.replace(/,\s*]/g, ']');
        
        return cleanedText;
    } catch (e) {
        // If cleaning fails, return original text
        return text;
    }
}

function renderQuiz(data) {
    try {
        // Store data for dark mode re-rendering
        window.lastLoadedData = data;
        
        // Clear existing charts first
        chartInstances.forEach(chart => chart.destroy());
        chartInstances = [];
        
        let questions = [];
        
        // Handle different JSON structures
        if (Array.isArray(data)) {
            questions = data;
        } else if (data.questions && Array.isArray(data.questions)) {
            questions = data.questions;
        } else if (typeof data === 'object') {
            // Check if it's a single question object
            if (data.id && data.prompt) {
                questions = [data];
            } else {
                // Try to extract questions from object properties
                questions = Object.values(data).filter(item => 
                    typeof item === 'object' && item.id && item.prompt
                );
            }
        }

        if (questions.length === 0) {
            showMessage('No valid questions found in the JSON data. Please check the format.');
            return;
        }

        showStats(questions);
        
        const questionsContainer = document.getElementById('questionsContainer');
        
        // Add app controls at the top
        let questionsHtml = `
            <div class="app-controls">
                <div class="user-info">
                    <input type="text" id="username" placeholder="Enter username" />
                </div>
                <div class="filter-controls">
                    <!-- Filters will be added in future steps -->
                </div>
                <button id="modeToggle" onclick="toggleMode()">Switch to View Mode</button>
            </div>
        `;
        
        questions.forEach((question, index) => {
            questionsHtml += renderQuestion(question, index);
        });
        
        questionsContainer.innerHTML = questionsHtml;
        
        // Trigger MathJax rendering for LaTeX content
        if (window.MathJax) {
            MathJax.typesetPromise().catch((e) => console.log('MathJax error:', e));
        }
        
        // Initialize context finder after questions are rendered
        initContextFinder();
        
        // Step 3: Load progress after rendering
        loadProgress();
        
        showMessage(`Successfully loaded ${questions.length} question(s)!`, 'success');
    } catch (error) {
        showMessage('Error rendering quiz: ' + error.message, 'error');
        console.error('Render error:', error);
    }
}

function updateContextFinder() {
    const contextDiv = document.getElementById('contextFinder');
    if (!contextDiv) return;

    const questionElements = document.querySelectorAll('.quiz-container');
    let currentEl = null;
    let minDistance = Number.POSITIVE_INFINITY;

    questionElements.forEach(el => {
        const rect = el.getBoundingClientRect();
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const viewportHeight = window.innerHeight;
        
        // Check if element is in viewport
        if (elementTop < viewportHeight && elementBottom > 0) {
            // Calculate distance from top of viewport
            const distance = Math.abs(elementTop);
            if (distance < minDistance) {
                minDistance = distance;
                currentEl = el;
            }
        }
    });

    if (currentEl) {
        const questionNumber = currentEl.getAttribute('data-question-number');
        const questionId = currentEl.getAttribute('data-question-id');
        contextDiv.innerHTML = `📍 Question ${questionNumber}<br><small>${questionId || 'No ID'}</small>`;
    }
}

function initContextFinder() {
    const contextDiv = document.getElementById('contextFinder');
    if (!contextDiv) return;

    // Disconnect previous observer if it exists (not used now but for cleanup)
    if (contextObserver) {
        contextObserver.disconnect();
    }

    // Attach scroll handler once
    if (!contextScrollHandlerAttached) {
        window.addEventListener('scroll', () => requestAnimationFrame(updateContextFinder));
        window.addEventListener('resize', () => requestAnimationFrame(updateContextFinder));
        contextScrollHandlerAttached = true;
    }

    // Initial content and display
    const questionElements = document.querySelectorAll('.quiz-container');
    if (questionElements.length > 0) {
        const firstQuestion = questionElements[0];
        const questionNumber = firstQuestion.getAttribute('data-question-number');
        const questionId = firstQuestion.getAttribute('data-question-id');
        contextDiv.innerHTML = `📍 Question ${questionNumber}<br><small>${questionId || 'No ID'}</small>`;
    }

    contextDiv.style.display = 'block';
    updateContextFinder();
}

// Mode toggle functionality
function toggleMode() {
    const currentMode = document.body.getAttribute('data-mode') || 'answer';
    const newMode = currentMode === 'answer' ? 'view' : 'answer';
    document.body.setAttribute('data-mode', newMode);
    
    const button = document.getElementById('modeToggle');
    if (button) {
        button.textContent = newMode === 'answer' ? 'Switch to View Mode' : 'Switch to Answer Mode';
    }
    
    buttonTones.click();
}

// Initialize mode on load
document.addEventListener('DOMContentLoaded', () => {
    document.body.setAttribute('data-mode', 'answer');
    
    // Check for username in localStorage
    const savedUsername = localStorage.getItem('consensusUsername');
    if (savedUsername) {
        const usernameInput = document.getElementById('username');
        if (usernameInput) {
            usernameInput.value = savedUsername;
        }
    }
    
    // Save username on change
    document.addEventListener('input', (e) => {
        if (e.target.id === 'username') {
            localStorage.setItem('consensusUsername', e.target.value);
        }
    });
});

// Load sample data on page load
window.onload = function() {
    initTheme();
    promptUsername();
    showMessage('🚀 Consensus Quiz Renderer Ready! Load your curriculum.json or use the debug button to start.', 'success');
};

// Generic click sound for ANY interactive element
document.addEventListener('click', (e) => {
    const choiceEl = e.target.closest('.choice');
    if (choiceEl) {
        buttonTones.click();
    }
});
</script>
</body>
</html>
CHUNK_5_END